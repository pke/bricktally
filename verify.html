<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Set Verification - BrickTally</title>
  <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg">

  <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.json">

  <!-- Mobile Web App Meta Tags -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="BrickTally">

  <link rel="stylesheet" href="/styles.css">
</head>

<body class="verify-page">
  <!-- Lightbox -->
  <div class="lightbox" id="lightbox">
    <span class="lightbox-close" id="lightboxClose">&times;</span>
    <img id="lightboxImage" src="" alt="">
  </div>

  <div class="container">
    <button class="theme-toggle" id="themeToggle" onclick="toggleDarkMode()">
      <span id="themeIcon">üåô</span>
    </button>

    <div id="content">
      <p>Loading verification data...</p>
    </div>

    <a href="/" class="back-link">‚Üê Back to BrickTally</a>
  </div>

  <script>
    var API_KEY = '6052dd0b655bdfede6e58d5166e96e76';
    var currentMissingParts = [];

    // Load dark mode preference from localStorage
    function loadDarkMode() {
      var darkMode = localStorage.getItem('darkMode');
      if (darkMode === 'true') {
        document.body.classList.add('dark-mode');
        updateThemeIcon();
      }
    }

    function toggleDarkMode() {
      document.body.classList.toggle('dark-mode');
      var isDark = document.body.classList.contains('dark-mode');
      localStorage.setItem('darkMode', isDark);
      updateThemeIcon();
    }

    function updateThemeIcon() {
      var isDark = document.body.classList.contains('dark-mode');
      var themeIcon = document.getElementById('themeIcon');
      // When dark mode is active, show sun (to switch to light)
      // When light mode is active, show moon (to switch to dark)
      themeIcon.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
    }

    // Initialize dark mode on page load
    loadDarkMode();

    // Detect preview environment and add banner
    if (window.location.hostname === 'preview.bricktally.app') {
      document.title = 'BrickTally Preview - Verify Parts';

      // Create preview banner
      var banner = document.createElement('div');
      banner.className = 'preview-banner';
      banner.textContent = 'PREVIEW';
      document.body.appendChild(banner);
    }

    // Setup lightbox event listeners
    var lightbox = document.getElementById('lightbox');
    var lightboxImage = document.getElementById('lightboxImage');
    var lightboxClose = document.getElementById('lightboxClose');
    var lightboxOriginRect = null;
    var lightboxOriginImage = null;

    // Event delegation for part images
    document.addEventListener('click', function(e) {
      if (e.target.classList.contains('part-image')) {
        var clickedImage = e.target;
        var rect = clickedImage.getBoundingClientRect();

        // Store origin for close animation
        lightboxOriginRect = rect;
        lightboxOriginImage = clickedImage;

        // Hide the original image (keep its space)
        clickedImage.classList.add('lightbox-active');

        // Set the lightbox image source
        lightboxImage.src = clickedImage.src;
        lightboxImage.alt = clickedImage.alt;

        // Position the image at the clicked image's location and size
        lightboxImage.style.top = rect.top + 'px';
        lightboxImage.style.left = rect.left + 'px';
        lightboxImage.style.width = rect.width + 'px';
        lightboxImage.style.height = rect.height + 'px';
        lightboxImage.style.maxWidth = rect.width + 'px';
        lightboxImage.style.maxHeight = rect.height + 'px';
        lightboxImage.style.transform = 'translate(0, 0)';

        // Show lightbox
        lightbox.style.display = 'flex';

        // Force reflow
        lightboxImage.offsetHeight;

        // Animate to center
        requestAnimationFrame(function() {
          lightbox.classList.add('active');
          lightboxImage.style.top = '50%';
          lightboxImage.style.left = '50%';
          lightboxImage.style.width = '';
          lightboxImage.style.height = '';
          lightboxImage.style.maxWidth = '90%';
          lightboxImage.style.maxHeight = '90%';
          lightboxImage.style.transform = 'translate(-50%, -50%)';
        });
      }
    });

    // Function to close lightbox
    function closeLightbox() {
      if (lightboxOriginRect) {
        // Animate back to origin
        lightbox.classList.remove('active');
        lightboxImage.style.top = lightboxOriginRect.top + 'px';
        lightboxImage.style.left = lightboxOriginRect.left + 'px';
        lightboxImage.style.width = lightboxOriginRect.width + 'px';
        lightboxImage.style.height = lightboxOriginRect.height + 'px';
        lightboxImage.style.maxWidth = lightboxOriginRect.width + 'px';
        lightboxImage.style.maxHeight = lightboxOriginRect.height + 'px';
        lightboxImage.style.transform = 'translate(0, 0)';

        setTimeout(function() {
          lightbox.style.display = 'none';
          // Restore original image visibility
          if (lightboxOriginImage) {
            lightboxOriginImage.classList.remove('lightbox-active');
            lightboxOriginImage = null;
          }
          lightboxOriginRect = null;
        }, 400);
      } else {
        lightbox.classList.remove('active');
        setTimeout(function() {
          lightbox.style.display = 'none';
        }, 300);
      }
    }

    // Close on X button
    lightboxClose.addEventListener('click', closeLightbox);

    // Close on background click
    lightbox.addEventListener('click', function(e) {
      if (e.target === lightbox) {
        closeLightbox();
      }
    });

    // Close on ESC key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && lightbox.classList.contains('active')) {
        closeLightbox();
      }
    });

    function getPartKey(part) {
      if (part.type === 'minifig') {
        // Use the API's unique ID for minifigs
        return 'fig_' + part.id;
      }

      var color = part.color || 'Unknown';
      var key = part.partNum + '_' + color;
      if (part.isSpare) {
        key += '_s';
      }
      return key;
    }

    function parseUrlParams() {
      var params = new URLSearchParams(window.location.search);
      return {
        setNumber: params.get('set'),
        missingData: params.get('missing') || ''
      };
    }

    function parseMissingData(missingData) {
      var missing = {};
      if (!missingData) return missing;

      missingData.split(',').forEach(function (part) {
        if (!part) return;
        var split = part.split(':');
        missing[split[0]] = parseInt(split[1]);
      });

      return missing;
    }

    function loadSetData(setNumber) {
      return fetch('https://rebrickable.com/api/v3/lego/sets/' + setNumber + '/', {
        headers: {
          'Accept': 'application/json',
          'Authorization': 'key ' + API_KEY
        }
      })
        .then(function (response) {
          if (!response.ok) throw new Error('Set not found');
          return response.json();
        });
    }

    function loadAllParts(setNumber) {
      var allParts = [];

      function fetchPage(page) {
        return fetch('https://rebrickable.com/api/v3/lego/sets/' + setNumber + '/parts/?page_size=1000&page=' + page, {
          headers: {
            'Accept': 'application/json',
            'Authorization': 'key ' + API_KEY
          }
        })
          .then(function (response) {
            if (!response.ok) throw new Error('Error fetching parts');
            return response.json();
          })
          .then(function (data) {
            if (data.results && data.results.length > 0) {
              allParts = allParts.concat(data.results);
            }

            if (data.next) {
              return fetchPage(page + 1);
            } else {
              return allParts;
            }
          });
      }

      return fetchPage(1);
    }

    function loadMinifigures(setNumber) {
      return fetch('https://rebrickable.com/api/v3/lego/sets/' + setNumber + '/minifigs/', {
        headers: {
          'Accept': 'application/json',
          'Authorization': 'key ' + API_KEY
        }
      })
      .then(function (response) {
        if (!response.ok) return { results: [] };
        return response.json();
      })
      .then(function (data) {
        return data.results || [];
      })
      .catch(function() {
        return [];
      });
    }

    function exportToBrickLink() {
      if (currentMissingParts.length === 0) {
        alert('No missing pieces to export!');
        return;
      }

      var xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
      xml += '<INVENTORY>\n';

      currentMissingParts.forEach(function (item) {
        xml += '  <ITEM>\n';
        if (item.part.type === 'minifig') {
          xml += '    <ITEMTYPE>M</ITEMTYPE>\n';
          xml += '    <ITEMID>' + item.part.partNum + '</ITEMID>\n';
        } else {
          xml += '    <ITEMTYPE>P</ITEMTYPE>\n';
          xml += '    <ITEMID>' + item.part.partNum + '</ITEMID>\n';
          xml += '    <COLORNAME>' + item.part.color + '</COLORNAME>\n';
        }
        xml += '    <MINQTY>' + item.missing + '</MINQTY>\n';
        xml += '  </ITEM>\n';
      });

      xml += '</INVENTORY>';

      var blob = new Blob([xml], { type: 'text/xml' });
      var url = window.URL.createObjectURL(blob);
      var a = document.createElement('a');
      a.href = url;
      a.download = 'bricklink-wanted-list-' + parseUrlParams().setNumber.replace('-', '_') + '.xml';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);

      alert('BrickLink XML file downloaded!\n\nTo use:\n1. Go to BrickLink.com\n2. Navigate to "Want" > "Upload"\n3. Select "BrickLink XML" format\n4. Upload the downloaded file');
    }

    function exportToPickABrick() {
      if (currentMissingParts.length === 0) {
        alert('No missing pieces to export!');
        return;
      }

      var csv = '# Note: Minifigures excluded (not available via Pick a Brick)\n';
      csv += 'Element ID,Design ID,Colour,Quantity,Name\n';

      currentMissingParts.forEach(function (item) {
        // Skip minifigs
        if (item.part.type === 'minifig') return;

        csv += ',' + item.part.partNum + ',' + item.part.color + ',' + item.missing + ',"' + item.part.name + '"\n';
      });

      var blob = new Blob([csv], { type: 'text/csv' });
      var url = window.URL.createObjectURL(blob);
      var a = document.createElement('a');
      a.href = url;
      a.download = 'pick-a-brick-list-' + parseUrlParams().setNumber.replace('-', '_') + '.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);

      alert('Pick a Brick CSV file downloaded!\n\nNote: This is a reference list. You\'ll need to manually search and add items on LEGO.com/pick-a-brick as they don\'t support bulk import.');
    }

    function exportMissingPartsText() {
      if (currentMissingParts.length === 0) {
        alert('No missing pieces to export!');
        return;
      }

      var setNumber = parseUrlParams().setNumber.split('-')[0];
      var text = 'Missing Pieces for Set ' + setNumber + '\n';
      text += '='.repeat(50) + '\n\n';

      var missingParts = [];
      var missingMinifigs = [];
      var totalPieces = 0;
      var totalMinifigs = 0;

      currentMissingParts.forEach(function (item) {
        if (item.part.type === 'minifig') {
          missingMinifigs.push(item);
          totalMinifigs += item.missing;
        } else {
          missingParts.push(item);
          totalPieces += item.missing;
        }
      });

      if (missingParts.length > 0) {
        text += 'PARTS:\n';
        missingParts.forEach(function (item) {
          text += item.missing + 'x ' + item.part.partNum + ' - ' + item.part.name + ' (' + item.part.color + ')\n';
        });
      }

      if (missingMinifigs.length > 0) {
        text += '\nMINIFIGURES:\n';
        missingMinifigs.forEach(function (item) {
          text += item.missing + 'x ' + item.part.partNum + ' - ' + item.part.name + '\n';
        });
      }

      text += '\n' + '='.repeat(50) + '\n';
      text += 'Total unique parts missing: ' + missingParts.length + '\n';
      if (missingMinifigs.length > 0) {
        text += 'Total unique minifigs missing: ' + missingMinifigs.length + '\n';
      }
      text += 'Total pieces missing: ' + totalPieces + '\n';
      if (totalMinifigs > 0) {
        text += 'Total minifigs missing: ' + totalMinifigs + '\n';
      }

      var blob = new Blob([text], { type: 'text/plain' });
      var url = window.URL.createObjectURL(blob);
      var a = document.createElement('a');
      a.href = url;
      a.download = 'missing-parts-' + parseUrlParams().setNumber.replace('-', '_') + '.txt';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }

    function displayVerification(setData, partsData, minifigsData, missingParts) {
      var totalPieces = 0;
      var missingPiecesCount = 0;
      var totalMinifigs = 0;
      var missingMinifigsCount = 0;
      var totalSpares = 0;
      var extraSparesCollected = 0;
      var missingPartsList = [];
      var missingMinifigsList = [];

      // Process parts
      partsData.forEach(function (item, index) {
        var part = {
          id: index,
          type: 'part',
          partNum: item.part.part_num || 'unknown',
          name: item.part.name || 'Unknown Part',
          color: (item.color && item.color.name) ? item.color.name : 'Unknown',
          quantity: item.quantity || 0,
          imageUrl: item.part.part_img_url || 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="60" height="60"%3E%3Crect width="60" height="60" fill="%23ddd"/%3E%3Ctext x="50%25" y="50%25" dominant-baseline="middle" text-anchor="middle" font-family="Arial" font-size="10" fill="%23999"%3ENo Image%3C/text%3E%3C/svg%3E',
          isSpare: item.is_spare || false
        };

        if (part.isSpare) {
          totalSpares += part.quantity;
          return;
        }

        totalPieces += part.quantity;
        var key = getPartKey(part);

        if (missingParts[key]) {
          missingPiecesCount += missingParts[key];
          missingPartsList.push({
            part: part,
            missing: missingParts[key]
          });
        }
      });

      // Process minifigs
      (minifigsData || []).forEach(function (item) {
        var minifig = {
          id: item.id,  // Use the API's unique ID
          type: 'minifig',
          partNum: item.set_num,
          name: item.set_name || 'Unknown Minifig',
          color: '',
          quantity: item.quantity,
          imageUrl: item.set_img_url || 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="60" height="60"%3E%3Crect width="60" height="60" fill="%23ddd"/%3E%3Ctext x="50%25" y="50%25" dominant-baseline="middle" text-anchor="middle" font-family="Arial" font-size="10" fill="%23999"%3ENo Image%3C/text%3E%3C/svg%3E',
          isSpare: false
        };

        totalMinifigs += minifig.quantity;
        var key = getPartKey(minifig);

        if (missingParts[key]) {
          missingMinifigsCount += missingParts[key];
          missingMinifigsList.push({
            part: minifig,
            missing: missingParts[key]
          });
        }
      });

      currentMissingParts = missingPartsList.concat(missingMinifigsList);

      // Combine all pieces (parts + minifigs)
      var allPieces = totalPieces + totalMinifigs;
      var allMissing = missingPiecesCount + missingMinifigsCount;
      var completedPieces = allPieces - allMissing;

      // Calculate extras from spare parts (if set is complete and we have spare data from localStorage)
      var isComplete = completedPieces === allPieces;
      if (isComplete && totalSpares > 0) {
        // This is a simplified calculation - in reality we'd need to check spare counts from localStorage
        // For verify page, we just show that spares exist
        extraSparesCollected = 0; // Can't calculate without spare part counts from localStorage
      }

      var percentage = allPieces > 0 ? Math.floor((completedPieces / allPieces) * 100) : 0;
      if (isComplete && extraSparesCollected > 0) {
        percentage = Math.floor(((completedPieces + extraSparesCollected) / allPieces) * 100);
      }

      var setImageUrl = setData.set_img_url || 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="400" height="300"%3E%3Crect width="400" height="300" fill="%23ddd"/%3E%3Ctext x="50%25" y="50%25" dominant-baseline="middle" text-anchor="middle" font-family="Arial" font-size="20" fill="%23999"%3ENo Image%3C/text%3E%3C/svg%3E';

      // Format set number for display
      var params = parseUrlParams();
      var versionParts = params.setNumber.split('-');
      var versionNumber = versionParts[1];
      var displaySetNumber = versionParts[0];
      var versionInfo = versionNumber !== '1' ?
        ' <span style="color: var(--orange);">(Version ' + versionNumber + ')</span>' : '';

      // Build pieces text for progress bar
      var piecesText = completedPieces + '/' + allPieces;
      if (extraSparesCollected > 0) {
        piecesText += ' +' + extraSparesCollected;
      }

      var html = '<div class="title-row">' +
        '<h1>üß± BrickTally - Set Verification</h1>' +
        '<div class="status-badge ' + (isComplete ? 'status-complete' : 'status-incomplete') + '">' +
        (isComplete ? '‚úì COMPLETE' : '‚ö† INCOMPLETE') +
        '</div>' +
        '</div>' +
        '<h2>' + setData.name + '</h2>' +
        '<p style="color: var(--text-secondary); margin: 10px 0 20px 0;">Set Number: ' + displaySetNumber + versionInfo + ' | Year: ' + setData.year + '</p>' +
        '<div class="set-header">' +
        '<img src="' + setImageUrl + '" alt="' + setData.name + '" class="set-image">' +
        '</div>' +
        '<div class="stats">' +
        '<h3>Progress Overview</h3>' +
        '<div class="stats-grid">' +
        '<div class="stat-item"><div class="stat-value">' + percentage + '%</div><div class="stat-label">Complete</div></div>' +
        '<div class="stat-item"><div class="stat-value">' + completedPieces + '</div><div class="stat-label">Pieces Found</div></div>' +
        '<div class="stat-item"><div class="stat-value">' + allMissing + '</div><div class="stat-label">Pieces Missing</div></div>' +
        '<div class="stat-item"><div class="stat-value">' + allPieces + '</div><div class="stat-label">Total Pieces</div></div>' +
        (totalSpares > 0 ? '<div class="stat-item"><div class="stat-value">' + totalSpares + '</div><div class="stat-label">Spare Parts</div></div>' : '') +
        '</div>' +
        '<div class="progress-bar" data-percentage="' + percentage + '%" data-pieces="' + piecesText + '">' +
        '<div class="progress-fill ' + (isComplete ? '' : 'incomplete') + '" style="width: ' + Math.min(percentage, 100) + '%;"></div>' +
        '</div>' +
        '</div>';

      if (missingPartsList.length === 0 && missingMinifigsList.length === 0) {
        html += '<div class="no-missing">' +
          '<div class="checkmark">‚úì</div>' +
          '<h2>All Pieces Accounted For!</h2>' +
          '<p>This set is 100% complete.</p>' +
          '</div>';
      } else {
        html += '<div style="margin-top: 30px;">' +
          '<!-- Replace the single export button with multiple options --><div style="margin-top: 30px; display: flex; gap: 10px; flex-wrap: wrap;">    <button class="export-btn" onclick="exportToBrickLink()">üì¶ BrickLink XML</button>    <button class="export-btn" onclick="exportToPickABrick()">üß± Pick a Brick CSV</button>    <button class="export-btn" onclick="exportMissingPartsText()">üìÑ Text List</button></div>' +
          '</div>';

        // Show missing parts if any
        if (missingPartsList.length > 0) {
          html += '<h3 style="margin-top: 30px;">Missing Parts (' + missingPartsList.length + ' unique parts)</h3>' +
            '<table>' +
            '<thead><tr>' +
            '<th style="width: 80px;">Image</th>' +
            '<th>Part</th>' +
            '<th class="missing-col" style="width: 120px;">Missing</th>' +
            '</tr></thead><tbody>';

          missingPartsList.forEach(function (item) {
            var partInfo = item.part.color + ' ' + item.part.name + '<br>' + item.part.partNum;

            html += '<tr>' +
              '<td><img src="' + item.part.imageUrl + '" alt="' + item.part.name + '" class="part-image"></td>' +
              '<td class="col-info">' + partInfo + '</td>' +
              '<td class="missing-col"><span class="missing-count">' + item.missing + '</span></td>' +
              '</tr>';
          });

          html += '</tbody></table>';
        }

        // Show missing minifigs if any
        if (missingMinifigsList.length > 0) {
          html += '<h3 style="margin-top: 30px;">Missing Minifigures (' + missingMinifigsList.length + ' unique minifigs)</h3>' +
            '<table>' +
            '<thead><tr>' +
            '<th style="width: 80px;">Image</th>' +
            '<th>Minifigure</th>' +
            '<th class="missing-col" style="width: 120px;">Missing</th>' +
            '</tr></thead><tbody>';

          missingMinifigsList.forEach(function (item) {
            // Parse name: "David - Dark Blue Vest, Black Trousers" -> "David<br>Dark Blue Vest, Black Trousers"
            var nameParts = item.part.name.split(' - ');
            var title = nameParts[0] || item.part.name;
            var description = nameParts.length > 1 ? nameParts.slice(1).join(' - ') : '';
            var minifigInfo = title + (description ? '<br>' + description : '');

            html += '<tr>' +
              '<td><img src="' + item.part.imageUrl + '" alt="' + item.part.name + '" class="part-image"></td>' +
              '<td class="col-info">' + minifigInfo + '</td>' +
              '<td class="missing-col"><span class="missing-count">' + item.missing + '</span></td>' +
              '</tr>';
          });

          html += '</tbody></table>';
        }
      }

      document.getElementById('content').innerHTML = html;
    }

    // Initialize
    var params = parseUrlParams();

    if (!params.setNumber) {
      document.getElementById('content').innerHTML = '<div class="no-missing"><h2>Invalid Verification Link</h2><p>No set specified.</p></div>';
    } else {
      var missingParts = parseMissingData(params.missingData);

      loadSetData(params.setNumber)
        .then(function (setData) {
          return Promise.all([loadAllParts(params.setNumber), loadMinifigures(params.setNumber)])
            .then(function (results) {
              return { setData: setData, partsData: results[0], minifigs: results[1] };
            });
        })
        .then(function (result) {
          displayVerification(result.setData, result.partsData, result.minifigs, missingParts);
        })
        .catch(function (error) {
          document.getElementById('content').innerHTML = '<div class="no-missing"><h2>Error Loading Set</h2><p>' + error.message + '</p></div>';
        });
    }
  </script>
</body>

</html>