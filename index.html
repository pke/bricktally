<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BrickTally - Every Brick Counts</title>
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/bricktally-icon.png">

    <!-- OpenGraph Meta Tags -->
    <meta property="og:title" content="BrickTally - Every Brick Counts">
    <meta property="og:description"
        content="Check if your LEGO¬Æ sets have all pieces before selling or storing. Count every brick to confirm 100% completeness.">
    <meta property="og:image" content="https://bricktally.app/assets/og-image.png">
    <meta property="og:url" content="https://bricktally.app">
    <meta property="og:type" content="website">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="BrickTally - Every Brick Counts">
    <meta name="twitter:description"
        content="Check if your LEGO¬Æ sets have all pieces before selling or storing. Count every brick to confirm 100% completeness.">
    <meta name="twitter:image" content="https://bricktally.app/assets/og-image.png">

    <!-- General Meta -->
    <meta name="description"
        content="Verify your LEGO¬Æ sets are complete before selling or storing. Count every piece and track multiple sets with BrickTally.">
    <meta name="keywords"
        content="LEGO¬Æ, set verification, brick counting, complete set checker, LEGO¬Æ inventory, sell LEGO¬Æ, used LEGO¬Æ sets">
    <meta name="theme-color" content="#0055BF">

    <!-- Canonical URL -->
    <link rel="canonical" href="https://bricktally.app/">

    <!-- Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "BrickTally",
        "url": "https://bricktally.app",
        "description": "Verify your LEGO¬Æ sets are complete before selling or storing. Count every piece and track multiple sets with BrickTally.",
        "applicationCategory": "UtilitiesApplication",
        "operatingSystem": "Any",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "image": "https://bricktally.app/assets/og-image.png",
        "author": {
            "@type": "Organization",
            "name": "BrickTally"
        }
    }
    </script>

    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">

    <!-- Mobile Web App Meta Tags -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="BrickTally">

    <!-- Windows Meta Tags -->
    <meta name="msapplication-TileColor" content="#0055BF">
    <meta name="msapplication-TileImage" content="/assets/bricktally-icon-512.png">

    <link rel="stylesheet" href="/styles.css">
    <script src="/js/lottie.min.js"></script>
    <script src="/js/pako.min.js"></script>
</head>

<body>
    <!-- Lightbox -->
    <div class="lightbox" id="lightbox">
        <span class="lightbox-close" id="lightboxClose">&times;</span>
        <img id="lightboxImage" src="" alt="">
    </div>

    <!-- Full header that scrolls normally -->
    <div class="full-header">
        <div class="header-wrapper" style="position: relative;">
            <button class="fullscreen-toggle" id="fullscreenToggle" onclick="toggleFullscreen()" aria-label="Toggle fullscreen">
                <span id="fullscreenIcon">‚õ∂</span>
            </button>
            <button class="theme-toggle" id="themeToggle" onclick="toggleDarkMode()" aria-label="Toggle dark mode">
                <span id="themeIcon"></span>
            </button>

            <div class="header-top">
                <div class="header-left">
                    <h1><a href="#" onclick="goToSetHistory(); return false;">üß± BrickTally</a></h1>
                    <div class="input-group">
                        <input type="number" id="setNumber" placeholder="Enter set number‚Ä¶" aria-label="LEGO set number" autocomplete="off" />
                    </div>
                </div>
            </div>

            <div id="setInfo" class="hide">
                <div class="set-info-layout">
                    <div id="setImageContainer" class="set-image-container"></div>
                    <div class="set-info-content">
                        <h2 id="setName"></h2>
                        <p id="setDetails"></p>
                        <div id="statsSection" class="hide">
                            <div class="stats text-center">
                                <span id="completedPieces">0</span> / <span id="totalPieces">0</span> pieces checked
                                <button id="resetButton" class="reset-inline hide" onclick="resetSet()" title="Reset progress" aria-label="Reset progress">‚Üª</button>
                            </div>
                            <div class="progress-bar" id="progressBar" data-percentage="0%" data-pieces="0/0">
                                <div id="progressFill" class="progress-fill" style="width: 0%;"></div>
                            </div>
                            <div id="spareProgressContainer" class="spare-progress-container hide">
                                <div class="spare-progress-label">Extra Spare Parts</div>
                                <div class="progress-bar spare-progress-bar" id="spareProgressBar" data-percentage="0%">
                                    <div id="spareProgressFill" class="progress-fill spare-progress-fill" style="width: 0%;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Collapsed header that appears when scrolling -->
    <div id="collapsedHeader" class="collapsed-header">
        <div class="header-wrapper">
            <div class="collapsed-row">
                <a href="#" class="collapsed-app-name" onclick="goToSetHistory(); return false;">üß± BrickTally</a>
                <div class="collapsed-set-name" id="collapsedSetName"></div>
            </div>
            <div class="collapsed-progress">
                <div class="progress-bar" id="progressBarCollapsed" data-percentage="0%" data-pieces="0/0">
                    <div id="progressFillCollapsed" class="progress-fill" style="width: 0%;"></div>
                </div>
                <div class="complete-toggle-container collapsed-toggle">
                    <button class="complete-toggle" id="completeToggleCollapsed" onclick="toggleCompleteParts()" title="Hide Complete Parts" aria-label="Hide complete parts"></button>
                    <span class="complete-toggle-label">Hide complete</span>
                </div>
            </div>
            <div class="collapsed-filters">
                <details id="colorFilterCollapsed" class="hide">
                    <summary>Colours</summary>
                    <div id="colorFiltersCollapsed" class="filters"></div>
                </details>
                <details id="infoFilterCollapsed" class="hide">
                    <summary>Columns</summary>
                    <div class="column-toggles" style="margin: 10px 0 0 0;">
                        <button class="column-toggle" onclick="toggleColumn('color', event)">Color</button>
                        <button class="column-toggle" onclick="toggleColumn('name', event)">Name</button>
                        <button class="column-toggle" onclick="toggleColumn('partNum', event)">Part Number</button>
                    </div>
                </details>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div class="content-area">
            <div id="loading" class="text-center p-20 hide">Loading set data‚Ä¶<div class="loading-spinner"></div></div>
            <div id="error" class="error text-center p-20 hide"></div>

            <!-- Set History Section -->
            <div id="setHistorySection" class="set-history hide">
                <div class="backup-restore-toolbar">
                    <button onclick="restoreSets()" class="restore-btn" title="Restore sets">üì• Restore</button>
                    <button id="backupAllBtn" onclick="startBackupAll()" class="backup-all-btn hide" title="Backup all sets">üì§ Backup All</button>
                    <button id="backupSelectedBtn" onclick="executeBackupAll()" class="backup-selected-btn" title="Backup selected sets">üì§ Backup Selected</button>
                    <button id="cancelBackupBtn" onclick="cancelBackupAll()" class="cancel-backup-btn" title="Cancel backup">Cancel</button>
                    <input type="file" id="restoreFileInput" accept=".bricktally,.json" class="hide" onchange="handleRestoreFile(event)">
                </div>
                <div id="setHistoryList" class="set-history-list"></div>
                <div id="setHistoryEmpty" class="set-history-empty hide">
                    <p>No sets worked on yet</p>
                    <p style="font-size: 14px;">Enter a set number above to get started</p>
                </div>
            </div>

            <!-- Restore Modal -->
            <div id="restoreModalOverlay" class="restore-modal-overlay">
                <div class="restore-modal">
                    <h3>Restore Sets</h3>
                    <div id="restoreSetList" class="restore-set-list"></div>
                    <div class="restore-modal-actions">
                        <button id="cancelRestoreBtn" onclick="cancelRestore()">Cancel</button>
                        <button id="executeRestoreBtn" onclick="executeRestore()">Restore Selected</button>
                    </div>
                </div>
            </div>

            <!-- Delete Confirmation Modal -->
            <div id="deleteModalOverlay" class="delete-modal-overlay">
                <div class="delete-modal">
                    <h3 id="deleteModalTitle">Delete Set?</h3>
                    <div id="deleteModalMessage"></div>
                    <div id="deleteModalActions" class="delete-modal-actions"></div>
                </div>
            </div>

            <div id="filterSection" class="hide">
                <div class="filter-headers">
                    <details class="filter-section" id="colorFilterSection">
                        <summary class="filter-header">
                            <span>Colours</span>
                            <span class="filter-arrow">‚ñº</span>
                        </summary>
                        <div id="colorFilters" class="filters filter-content-flex"></div>
                    </details>

                    <details class="filter-section" id="columnsFilterSection">
                        <summary class="filter-header">
                            <span>Columns</span>
                            <span class="filter-arrow">‚ñº</span>
                        </summary>
                        <div class="column-toggles filter-content-flex">
                            <button class="column-toggle" onclick="toggleColumn('color', event)">Color</button>
                            <button class="column-toggle" onclick="toggleColumn('name', event)">Name</button>
                            <button class="column-toggle" onclick="toggleColumn('partNum', event)">Part Number</button>
                        </div>
                    </details>

                    <details class="filter-section" id="exportFilterSection">
                        <summary class="filter-header">
                            <span>Export</span>
                            <span class="filter-arrow">‚ñº</span>
                        </summary>
                        <div class="filter-content-stack">
                            <button onclick="generateBadge()" class="export-btn" style="background: var(--green);">üè∑Ô∏è Generate Badge</button>
                            <button onclick="exportToBrickLink()" class="export-btn" style="background: var(--orange);">üì¶ BrickLink XML</button>
                            <button onclick="exportToPickABrick()" class="export-btn" style="background: var(--red);">üß± Pick a Brick CSV</button>
                            <button onclick="exportMissingPartsText()" class="export-btn" style="background: var(--blue);">üìÑ Text List</button>
                            <button onclick="exportToRebrickable()" class="export-btn" style="background: #6b5b95;">üß© Export partlist</button>
                        </div>
                    </details>
                </div>
            </div>

            <div id="minifigSection" class="hide m-20">
                <div class="section-header-row">
                    <h3 id="minifigHeader" style="margin: 0;">Minifigures</h3>
                </div>
                <div id="minifigContainer"></div>
            </div>

            <div id="partsSection" class="hide m-20">
                <div class="section-header-row">
                    <h3 id="partsHeader" style="margin: 0;">Parts</h3>
                </div>
            </div>

            <div id="tableContainer"></div>

            <div id="sparePartsSection" class="hide m-20">
                <div class="section-header-row">
                    <h3 id="sparePartsHeader" style="margin: 0;">Spare Parts</h3>
                </div>
            </div>

            <div class="complete-toggle-container" id="completeToggleContainer" style="display: none;">
                <button class="complete-toggle" id="completeToggle" onclick="toggleCompleteParts()" title="Hide complete parts" aria-label="Hide complete parts"></button>
                <span class="complete-toggle-label">Hide complete</span>
            </div>

            <div id="spareTableContainer"></div>
        </div>
    </div>

    <script>
        // Service Worker Registration
        var waitingWorker = null;
        var userRequestedUpdate = false;

        if ('serviceWorker' in navigator) {
            // Reload once the new SW takes control (only if user clicked "Update Now")
            navigator.serviceWorker.addEventListener('controllerchange', function() {
                if (userRequestedUpdate) {
                    window.location.reload();
                }
            });

            window.addEventListener('load', function() {
                // Store current version for changelog comparison
                var versionEl = document.getElementById('versionInfo');
                if (versionEl) {
                    var versionMatch = versionEl.textContent.match(/v([\d.]+)/);
                    if (versionMatch && !localStorage.getItem('lastSeenVersion')) {
                        localStorage.setItem('lastSeenVersion', versionMatch[1]);
                    }
                }

                navigator.serviceWorker.register('/sw.js')
                    .then(function(registration) {
                        console.log('[BrickTally:ServiceWorker] ServiceWorker registered');

                        // Handle updates
                        registration.addEventListener('updatefound', function() {
                            var newWorker = registration.installing;
                            newWorker.addEventListener('statechange', function() {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    waitingWorker = newWorker;
                                    showWhatsNewModal();
                                }
                            });
                        });
                    })
                    .catch(function(error) {
                        console.log('[BrickTally:ServiceWorker] ServiceWorker registration failed:', error);
                    });
            });
        }

        function showWhatsNewModal() {
            fetch('/changelog.json?_=' + Date.now())
                .then(function(response) { return response.json(); })
                .then(function(changelog) {
                    var lastSeen = localStorage.getItem('lastSeenVersion') || '0.0.0';
                    // Collect entries from all versions newer than lastSeen
                    var newEntries = [];
                    var latestVersion = changelog.length > 0 ? changelog[0].version : lastSeen;

                    changelog.forEach(function(release) {
                        if (compareVersions(release.version, lastSeen) > 0) {
                            newEntries = newEntries.concat(release.entries);
                        }
                    });

                    buildWhatsNewModal(latestVersion, newEntries);
                })
                .catch(function() {
                    // changelog.json unavailable ‚Äî show simple update prompt
                    buildWhatsNewModal(null, []);
                });
        }

        function compareVersions(a, b) {
            var pa = a.split('.').map(Number);
            var pb = b.split('.').map(Number);
            for (var i = 0; i < 3; i++) {
                if ((pa[i] || 0) > (pb[i] || 0)) return 1;
                if ((pa[i] || 0) < (pb[i] || 0)) return -1;
            }
            return 0;
        }

        function buildWhatsNewModal(version, entries) {
            var overlay = document.createElement('div');
            overlay.className = 'whats-new-overlay';

            var modal = document.createElement('div');
            modal.className = 'whats-new-modal';

            var title = document.createElement('h2');
            title.className = 'whats-new-title';
            title.textContent = '\u2728 What\u2019s New in BrickTally';
            modal.appendChild(title);

            if (entries.length > 0) {
                var list = document.createElement('ul');
                list.className = 'whats-new-entries';
                entries.forEach(function(entry) {
                    var li = document.createElement('li');
                    li.textContent = entry;
                    list.appendChild(li);
                });
                modal.appendChild(list);

                var changelogLink = document.createElement('a');
                changelogLink.href = '/changelog';
                changelogLink.className = 'whats-new-changelog-link';
                changelogLink.textContent = 'See full changelog ‚Üí';
                modal.appendChild(changelogLink);
            } else {
                var msg = document.createElement('p');
                msg.className = 'whats-new-message';
                msg.textContent = 'A new version is available.';
                modal.appendChild(msg);
            }

            var actions = document.createElement('div');
            actions.className = 'whats-new-actions';

            var updateBtn = document.createElement('button');
            updateBtn.className = 'whats-new-update-btn';
            updateBtn.textContent = 'Update Now';
            updateBtn.onclick = function() {
                if (version) localStorage.setItem('lastSeenVersion', version);
                userRequestedUpdate = true;
                if (waitingWorker) {
                    waitingWorker.postMessage({ type: 'SKIP_WAITING' });
                } else {
                    window.location.reload();
                }
            };

            var laterBtn = document.createElement('button');
            laterBtn.className = 'whats-new-later-btn';
            laterBtn.textContent = 'Maybe Later';
            laterBtn.onclick = function() {
                if (version) localStorage.setItem('lastSeenVersion', version);
                overlay.remove();
            };

            actions.appendChild(updateBtn);
            actions.appendChild(laterBtn);
            modal.appendChild(actions);

            overlay.appendChild(modal);
            document.body.appendChild(overlay);

            // Dismiss on overlay click or Escape key
            overlay.addEventListener('click', function(e) {
                if (e.target === overlay) laterBtn.click();
            });
            document.addEventListener('keydown', function onEscape(e) {
                if (e.key === 'Escape' && document.querySelector('.whats-new-overlay')) {
                    laterBtn.click();
                    document.removeEventListener('keydown', onEscape);
                }
            });
        }

        var partsData = [];
        var userCounts = {};
        var currentSetNumber = '';
        var activeColorFilters = [];
        var showCompleteParts = false;
        var visibleColumns = {
            partNum: false,
            name: false,
            color: false
        };

        function getPartKey(part) {
            if (part.type === 'minifig') {
                // Use the API's unique ID for minifigs
                return 'fig_' + part.id;
            }

            var color = part.color || 'Unknown';
            var key = part.partNum + '_' + color;
            if (part.isSpare) {
                key += '_s';
            }
            return key;
        }

        // Proxy Rebrickable CDN URLs through our API (used for canvas CORS and fallback)
        function getProxiedUrl(url) {
            if (url && (url.startsWith('https://cdn.rebrickable.com/') || url.startsWith('https://rebrickable.com/'))) {
                return '/api/image-proxy?url=' + encodeURIComponent(url);
            }
            return url;
        }

        // Handle image load errors ‚Äî retry through proxy if CDN is blocked (e.g. uMatrix)
        window.handleImageError = function(img) {
            var src = img.getAttribute('src');
            if (!src) return;
            // If a direct CDN URL failed, retry through our same-origin proxy
            if (src.startsWith('https://cdn.rebrickable.com/') || src.startsWith('https://rebrickable.com/')) {
                img.src = getProxiedUrl(src);
            }
        };

        window.handleImageLoad = function(img) {
            // Currently unused
        };

        // ‚îÄ‚îÄ‚îÄ localStorage helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        function getSetData(fullNumber) {
            var raw = localStorage.getItem('set_' + fullNumber);
            if (!raw) return null;
            try {
                var data = JSON.parse(raw);
                if (data && data.fullNumber) return data;
                return null;
            } catch (e) {
                return null;
            }
        }

        function saveSetData(fullNumber, data) {
            localStorage.setItem('set_' + fullNumber, JSON.stringify(data));
        }

        function removeSetData(fullNumber) {
            localStorage.removeItem('set_' + fullNumber);
            localStorage.removeItem('setInfo_' + fullNumber);
            localStorage.removeItem('setData_' + fullNumber);
            localStorage.removeItem('backupInfo_' + fullNumber);
        }

        function migrateLocalStorage() {
            var keysToRemove = [];
            var keysCount = localStorage.length;

            for (var i = 0; i < keysCount; i++) {
                var key = localStorage.key(i);
                if (!key || !key.startsWith('setInfo_')) continue;

                var fullNumber = key.substring('setInfo_'.length);
                var infoStr = localStorage.getItem(key);
                if (!infoStr) continue;

                try {
                    var info = JSON.parse(infoStr);
                } catch (e) {
                    continue;
                }

                // Check if set_ already holds new-format JSON
                var existingSetValue = localStorage.getItem('set_' + fullNumber);
                if (existingSetValue && existingSetValue.charAt(0) === '{') {
                    try {
                        var parsed = JSON.parse(existingSetValue);
                        if (parsed.fullNumber) {
                            keysToRemove.push(key);
                            continue;
                        }
                    } catch (e) {
                        // Not valid JSON, treat as old progress string
                    }
                }

                // Build consolidated object
                var consolidated = {
                    number: info.number,
                    fullNumber: info.fullNumber,
                    name: info.name,
                    year: info.year,
                    numParts: info.numParts,
                    imageUrl: info.imageUrl,
                    lastAccessed: info.lastAccessed,
                    progress: existingSetValue || ''
                };

                localStorage.setItem('set_' + fullNumber, JSON.stringify(consolidated));
                keysToRemove.push(key);
                keysToRemove.push('setData_' + fullNumber);
            }

            keysToRemove.forEach(function(k) {
                localStorage.removeItem(k);
            });
        }

        // ‚îÄ‚îÄ‚îÄ Progress compression helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        function compressProgress(parts, counts) {
            var PROGRESS_VERSION = 1;
            var pickedEntries = [];
            var remainingEntries = [];

            parts.forEach(function(part) {
                var key = getPartKey(part);
                var picked = counts[key] || 0;
                var type;
                if (part.type === 'minifig') type = 2;
                else if (part.isSpare) type = 1;
                else type = 0;

                if (picked > 0 && picked < part.quantity) {
                    pickedEntries.push([part.partNum, part.colorId || 0, picked, type]);
                    remainingEntries.push([part.partNum, part.colorId || 0, part.quantity - picked, type]);
                } else if (picked >= part.quantity) {
                    pickedEntries.push([part.partNum, part.colorId || 0, picked, type]);
                } else {
                    remainingEntries.push([part.partNum, part.colorId || 0, part.quantity, type]);
                }
            });

            var usePicked = pickedEntries.length <= remainingEntries.length;
            var mode = usePicked ? 0 : 1;
            var entries = usePicked ? pickedEntries : remainingEntries;

            // Mode 0 with no entries = nothing picked = 0%
            if (mode === 0 && entries.length === 0) return '';

            var arr = [PROGRESS_VERSION, mode];
            for (var i = 0; i < entries.length; i++) {
                arr.push(entries[i]);
            }

            var json = JSON.stringify(arr);
            var compressed = pako.deflateRaw(new TextEncoder().encode(json), { level: 9 });

            var binary = '';
            for (var j = 0; j < compressed.length; j++) {
                binary += String.fromCharCode(compressed[j]);
            }
            return btoa(binary)
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');
        }

        function decompressProgress(progressString, parts) {
            var counts = {};

            if (!progressString) return counts;

            // Old format: contains colon (e.g. "3001_Red:5,3004_Blue:3")
            if (progressString.indexOf(':') !== -1) {
                progressString.split(',').forEach(function(part) {
                    if (!part) return;
                    var split = part.split(':');
                    counts[split[0]] = parseInt(split[1]) || 0;
                });
                return counts;
            }

            // New compressed format: base64url -> inflate -> JSON
            try {
                var base64 = progressString.replace(/-/g, '+').replace(/_/g, '/');
                while (base64.length % 4 !== 0) base64 += '=';
                var binary = atob(base64);
                var bytes = new Uint8Array(binary.length);
                for (var i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }

                var inflated = pako.inflateRaw(bytes, { to: 'string' });
                var arr = JSON.parse(inflated);

                var mode = arr[1]; // 0 = picked, 1 = remaining

                // Build lookup: partNum|colorId|type -> { key, quantity }
                var lookup = {};
                parts.forEach(function(part) {
                    var key = getPartKey(part);
                    var type;
                    if (part.type === 'minifig') type = 2;
                    else if (part.isSpare) type = 1;
                    else type = 0;
                    lookup[part.partNum + '|' + (part.colorId || 0) + '|' + type] = {
                        key: key,
                        quantity: part.quantity
                    };
                });

                var seenKeys = {};
                for (var j = 2; j < arr.length; j++) {
                    var entry = arr[j];
                    var lookupKey = entry[0] + '|' + entry[1] + '|' + entry[3];
                    var info = lookup[lookupKey];
                    if (!info) continue;

                    if (mode === 0) {
                        counts[info.key] = entry[2];
                    } else {
                        counts[info.key] = info.quantity - entry[2];
                    }
                    seenKeys[info.key] = true;
                }

                // Mode 1: parts NOT in list are fully complete
                if (mode === 1) {
                    parts.forEach(function(part) {
                        var key = getPartKey(part);
                        if (!seenKeys[key] && !counts.hasOwnProperty(key)) {
                            counts[key] = part.quantity;
                        }
                    });
                }

                return counts;
            } catch (e) {
                console.error('Failed to decompress progress:', e);
                return counts;
            }
        }

        function calculateProgressCompressed(numParts, progressString) {
            if (!progressString) return { completed: 0, total: numParts, percentage: 0 };

            try {
                var base64 = progressString.replace(/-/g, '+').replace(/_/g, '/');
                while (base64.length % 4 !== 0) base64 += '=';
                var binary = atob(base64);
                var bytes = new Uint8Array(binary.length);
                for (var i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                var inflated = pako.inflateRaw(bytes, { to: 'string' });
                var arr = JSON.parse(inflated);

                var mode = arr[1];
                var sum = 0;
                for (var j = 2; j < arr.length; j++) {
                    sum += arr[j][2];
                }

                var completed = (mode === 0) ? sum : numParts - sum;
                var percentage = numParts > 0 ? Math.round((completed / numParts) * 100) : 0;
                return { completed: completed, total: numParts, percentage: percentage };
            } catch (e) {
                return { completed: 0, total: numParts, percentage: 0 };
            }
        }

        function saveSetInfo(setNumber, setData) {
            var existing = getSetData(setNumber) || {};
            existing.number = setNumber.split('-')[0];
            existing.fullNumber = setNumber;
            existing.name = setData.name;
            existing.year = setData.year;
            existing.numParts = setData.num_parts || 0;
            existing.imageUrl = setData.set_img_url || 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="50" height="50"%3E%3Crect width="50" height="50" fill="%23ddd"/%3E%3Ctext x="50%25" y="50%25" dominant-baseline="middle" text-anchor="middle" font-family="Arial" font-size="10" fill="%23999"%3ENo Image%3C/text%3E%3C/svg%3E';
            existing.lastAccessed = Date.now();
            if (!existing.progress) existing.progress = '';
            saveSetData(setNumber, existing);
        }

        function getSetHistory() {
            var sets = [];

            for (var i = 0; i < localStorage.length; i++) {
                var key = localStorage.key(i);
                if (key && key.startsWith('set_')) {
                    try {
                        var data = JSON.parse(localStorage.getItem(key));
                        if (data && data.fullNumber && data.name) {
                            sets.push(data);
                        }
                    } catch (e) {
                        // Skip non-JSON entries
                    }
                }
            }

            sets.sort(function(a, b) {
                return (b.lastAccessed || 0) - (a.lastAccessed || 0);
            });

            return sets;
        }

        function displaySetHistory() {
            var sets = getSetHistory();
            var historySection = document.getElementById('setHistorySection');
            var historyList = document.getElementById('setHistoryList');
            var historyEmpty = document.getElementById('setHistoryEmpty');
            var backupAllBtn = document.getElementById('backupAllBtn');

            if (sets.length === 0) {
                historyList.innerHTML = '';
                historyEmpty.classList.remove('hide');
                if (backupAllBtn) backupAllBtn.classList.add('hide');
                return;
            }

            historyEmpty.classList.add('hide');
            if (backupAllBtn) backupAllBtn.classList.remove('hide');
            historyList.innerHTML = '';

            sets.forEach(function(setInfo) {
                // Calculate progress from the consolidated object
                var totalCount = setInfo.numParts || 0;
                var prog = calculateProgressFromString(totalCount, setInfo.progress || '');
                var completedCount = prog.completed;
                var percentage = prog.percentage;

                // Note: innerHTML used here with app-controlled data only (setInfo from localStorage written by this app)
                var item = document.createElement('div');
                item.className = 'set-history-item';
                item.setAttribute('data-set-number', setInfo.fullNumber);

                item.innerHTML =
                    '<img src="' + setInfo.imageUrl + '" alt="' + setInfo.name + '" class="set-history-item-image" onerror="handleImageError(this)" onclick="retryImageLoad(this)">' +
                    '<div class="set-history-item-content">' +
                        '<div class="set-history-item-title">' + setInfo.name + '</div>' +
                        '<div class="set-history-item-number">Set ' + setInfo.number + ' (' + setInfo.year + ')</div>' +
                        '<div class="set-history-item-stats">' + completedCount + ' / ' + totalCount + ' pieces</div>' +
                        '<div class="progress-bar" data-percentage="' + percentage + '%">' +
                            '<div class="progress-fill" style="width: ' + percentage + '%;"></div>' +
                        '</div>' +
                    '</div>' +
                    '<div class="set-history-item-actions">' +
                        '<button class="backup" onclick="backupSingleSet(event, \'' + setInfo.fullNumber + '\')" title="Backup set">üì§</button>' +
                        '<button class="reset" onclick="resetSetHistory(event, \'' + setInfo.fullNumber + '\')" title="Reset progress">‚Üª</button>' +
                        '<button class="delete" onclick="deleteSetHistory(event, \'' + setInfo.fullNumber + '\')" title="Delete set">‚úï</button>' +
                    '</div>';

                // Click on row to load set or toggle backup checkbox
                item.addEventListener('click', function(e) {
                    // Don't trigger if clicking buttons or checkboxes
                    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;

                    // In backup selection mode, toggle checkbox instead of loading set
                    var cb = this.querySelector('input[type="checkbox"]');
                    if (cb) {
                        cb.checked = !cb.checked;
                        this.classList.toggle('backup-selected', cb.checked);
                        return;
                    }

                    document.getElementById('setNumber').value = setInfo.number;
                    loadSetDirect(setInfo.fullNumber);
                });

                historyList.appendChild(item);
            });
        }

        var pendingDeleteSetNumber = null;

        function deleteSetHistory(event, setNumber) {
            event.stopPropagation();
            pendingDeleteSetNumber = setNumber;

            var data = getSetData(setNumber) || {};
            var setName = data.name || setNumber;
            var setNum = data.number || setNumber.split('-')[0];

            var currentProgress = data.progress || '';

            var titleEl = document.getElementById('deleteModalTitle');
            var messageEl = document.getElementById('deleteModalMessage');
            var actionsEl = document.getElementById('deleteModalActions');

            titleEl.textContent = 'Delete "' + setName + '" (Set ' + setNum + ')?';

            var actionsHtml = '';
            var hasProgress = currentProgress !== '';

            if (!hasProgress) {
                // No parts counted ‚Äî nothing to lose, simple delete
                messageEl.innerHTML = '';
                actionsHtml += '<button id="confirmDeleteBtn" onclick="confirmDelete()">Delete</button>';
            } else if (data.backup) {
                var currentProg = calculateProgressFromString(data.numParts || 0, currentProgress);
                var backupCompleted = data.backupCompleted || 0;
                if (backupCompleted === currentProg.completed) {
                    // State 1: Backup is current
                    var backupPercentage = data.numParts > 0 ? Math.round(backupCompleted / data.numParts * 100) : 0;
                    messageEl.innerHTML = '<div class="delete-status-safe">‚úÖ Safe to delete ‚Äî backed up ' + formatDate(data.backup) + ' (' + backupPercentage + '% complete)</div>';
                    actionsHtml += '<button id="confirmDeleteBtn" onclick="confirmDelete()">Delete</button>';
                } else {
                    // State 2: Backup is outdated
                    var backupPercentage = data.numParts > 0 ? Math.round(backupCompleted / data.numParts * 100) : 0;
                    var backupParts = backupCompleted + '/' + (data.numParts || 0);
                    var currentParts = currentProg.completed + '/' + currentProg.total;
                    messageEl.innerHTML = '<div class="delete-status-warning">‚ö†Ô∏è Backup is outdated ‚Äî backed up ' + formatDate(data.backup) + ' at ' + backupPercentage + '% (' + backupParts + ' pieces), now ' + currentProg.percentage + '% (' + currentParts + ' pieces)</div>';
                    actionsHtml += '<button id="confirmDeleteBtn" onclick="confirmDelete()">Delete</button>';
                    actionsHtml += '<button id="backupAndDeleteBtn" onclick="backupAndDelete()">Backup & Delete</button>';
                }
            } else {
                // State 3: Never backed up but has progress
                messageEl.innerHTML = '<div class="delete-status-warning">‚ö†Ô∏è This set has never been backed up!</div>';
                actionsHtml += '<button id="confirmDeleteBtn" onclick="confirmDelete()">Delete</button>';
                actionsHtml += '<button id="backupAndDeleteBtn" onclick="backupAndDelete()">Backup & Delete</button>';
            }

            actionsHtml += '<button id="cancelDeleteBtn" onclick="cancelDelete()">Cancel</button>';

            actionsEl.innerHTML = actionsHtml;
            document.getElementById('deleteModalOverlay').setAttribute('data-visible', '');
        }

        window.cancelDelete = function() {
            document.getElementById('deleteModalOverlay').removeAttribute('data-visible');
            pendingDeleteSetNumber = null;
        };

        window.confirmDelete = function() {
            if (!pendingDeleteSetNumber) return;
            removeSetData(pendingDeleteSetNumber);
            document.getElementById('deleteModalOverlay').removeAttribute('data-visible');
            pendingDeleteSetNumber = null;
            displaySetHistory();
        };

        window.backupAndDelete = function() {
            if (!pendingDeleteSetNumber) return;
            var setNumber = pendingDeleteSetNumber;

            // Build and download backup
            var data = buildBackupData([setNumber]);
            var baseNumber = setNumber.split('-')[0];
            downloadBricktally(data, 'BrickTally-' + baseNumber + '.bricktally');

            // Then delete
            removeSetData(setNumber);
            document.getElementById('deleteModalOverlay').removeAttribute('data-visible');
            pendingDeleteSetNumber = null;
            displaySetHistory();
        };

        function resetSetHistory(event, setNumber) {
            event.stopPropagation();

            if (!confirm('Are you sure you want to reset all progress for this set?')) {
                return;
            }

            var data = getSetData(setNumber);
            if (data) {
                data.progress = '';
                saveSetData(setNumber, data);
            }

            // Refresh the display
            displaySetHistory();
        }

        // ‚îÄ‚îÄ‚îÄ Backup/Restore Functions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        function getAppVersion() {
            var versionText = document.getElementById('versionInfo').textContent || '';
            var match = versionText.match(/v(\d+\.\d+\.\d+)/);
            return 'BrickTally/' + (match ? match[1] : '0.0.0');
        }

        function calculateProgressFromString(numParts, progressString) {
            if (!progressString) return { completed: 0, total: numParts, percentage: 0 };

            // Old format contains colon; new compressed format is base64url only
            if (progressString.indexOf(':') !== -1) {
                var completed = 0;
                progressString.split(',').forEach(function(part) {
                    if (!part) return;
                    var split = part.split(':');
                    completed += parseInt(split[1]) || 0;
                });
                var percentage = numParts > 0 ? Math.round((completed / numParts) * 100) : 0;
                return { completed: completed, total: numParts, percentage: percentage };
            }

            return calculateProgressCompressed(numParts, progressString);
        }

        function formatDate(timestamp) {
            if (!timestamp) return 'Unknown';
            var d = new Date(timestamp);
            var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            return months[d.getMonth()] + ' ' + d.getDate() + ', ' + d.getFullYear();
        }

        function validateBricktally(data) {
            if (!data || typeof data !== 'object') return false;
            if (data.version !== 1) return false;
            if (typeof data.exportedAt !== 'string') return false;
            if (typeof data.app !== 'string' || !data.app.match(/^BrickTally\/.+$/)) return false;
            if (!Array.isArray(data.sets) || data.sets.length === 0) return false;
            for (var i = 0; i < data.sets.length; i++) {
                var s = data.sets[i];
                if (!s.fullNumber || !s.info || typeof s.lastWorkedOn !== 'number') return false;
                if (!s.info.name || !s.info.fullNumber) return false;
            }
            return true;
        }

        function buildBackupData(fullNumbers) {
            var sets = [];
            fullNumbers.forEach(function(fullNumber) {
                var data = getSetData(fullNumber);
                if (!data) return;
                var progress = data.progress || '';
                sets.push({
                    fullNumber: fullNumber,
                    info: {
                        number: data.number,
                        fullNumber: data.fullNumber,
                        name: data.name,
                        year: data.year,
                        numParts: data.numParts,
                        imageUrl: data.imageUrl,
                        lastAccessed: data.lastAccessed
                    },
                    progress: progress,
                    lastWorkedOn: data.lastAccessed || 0
                });
            });

            // Record backup state in consolidated object
            sets.forEach(function(s) {
                var data = getSetData(s.fullNumber);
                if (data) {
                    data.backup = Date.now();
                    data.backupCompleted = calculateProgressFromString(data.numParts || 0, s.progress).completed;
                    saveSetData(s.fullNumber, data);
                }
            });

            return {
                version: 1,
                exportedAt: new Date().toISOString(),
                app: getAppVersion(),
                sets: sets
            };
        }

        function downloadBricktally(data, filename) {
            var blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        window.backupSingleSet = function(event, fullNumber) {
            event.stopPropagation();
            var data = buildBackupData([fullNumber]);
            var baseNumber = fullNumber.split('-')[0];
            downloadBricktally(data, 'BrickTally-' + baseNumber + '.bricktally');
        };

        window.startBackupAll = function() {
            // Enter backup selection mode
            document.querySelector('.backup-restore-toolbar').setAttribute('data-backup-mode', '');

            // Add checkboxes to each set card
            var items = document.querySelectorAll('.set-history-item');
            items.forEach(function(item) {
                if (item.querySelector('input[type="checkbox"]')) return;
                var checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = true;
                checkbox.className = 'backup-checkbox';
                checkbox.onclick = function(e) {
                    e.stopPropagation();
                    item.classList.toggle('backup-selected', checkbox.checked);
                };
                item.insertBefore(checkbox, item.firstChild);
                item.classList.add('backup-selected');
            });
        };

        window.cancelBackupAll = function() {
            // Exit backup selection mode
            document.querySelector('.backup-restore-toolbar').removeAttribute('data-backup-mode');

            // Remove checkboxes and selection styling
            document.querySelectorAll('.set-history-item').forEach(function(item) {
                var cb = item.querySelector('input[type="checkbox"]');
                if (cb) cb.remove();
                item.classList.remove('backup-selected');
            });
        };

        window.executeBackupAll = function() {
            var selected = [];
            document.querySelectorAll('.set-history-item').forEach(function(item) {
                var cb = item.querySelector('input[type="checkbox"]');
                if (cb && cb.checked) {
                    selected.push(item.getAttribute('data-set-number'));
                }
            });

            if (selected.length === 0) {
                alert('No sets selected for backup.');
                return;
            }

            var data = buildBackupData(selected);
            var today = new Date().toISOString().split('T')[0];
            downloadBricktally(data, 'BrickTally-backup-' + today + '.bricktally');
            cancelBackupAll();
        };

        window.restoreSets = function() {
            var input = document.getElementById('restoreFileInput');
            input.value = '';
            input.click();
        };

        window.handleRestoreFile = function(event) {
            var file = event.target.files[0];
            if (!file) return;

            var reader = new FileReader();
            reader.onload = function(e) {
                try {
                    var data = JSON.parse(e.target.result);
                    if (!validateBricktally(data)) {
                        alert('Invalid .bricktally file: does not match expected format.');
                        return;
                    }
                    showRestoreDialog(data);
                } catch (err) {
                    alert('Invalid .bricktally file: could not parse JSON.');
                }
            };
            reader.readAsText(file);
        };

        var pendingRestoreData = null;

        function showRestoreDialog(restoreData) {
            pendingRestoreData = restoreData;
            var listEl = document.getElementById('restoreSetList');
            listEl.innerHTML = '';

            restoreData.sets.forEach(function(restoreSet) {
                var localData = getSetData(restoreSet.fullNumber);
                var hasConflict = !!localData;

                var itemEl = document.createElement('div');
                itemEl.className = 'restore-set-item' + (hasConflict ? ' restore-conflict' : '');
                itemEl.setAttribute('data-set-number', restoreSet.fullNumber);

                var restoreProgress = calculateProgressFromString(restoreSet.info.numParts, restoreSet.progress);

                var imgUrl = restoreSet.info.imageUrl || '/assets/favicon.svg';
                var html = '<img src="' + imgUrl + '" class="restore-set-image" onerror="handleImageError(this)">' +
                    '<div class="restore-set-info">' +
                    '<strong>' + restoreSet.info.name + '</strong>' +
                    '<span>Set ' + restoreSet.info.number + ' (' + restoreSet.info.year + ')</span>' +
                    '</div>';

                if (hasConflict) {
                    var localProgress = calculateProgressFromString(
                        localData.numParts,
                        localData.progress || ''
                    );

                    var restoreIsNewer = restoreSet.lastWorkedOn > (localData.lastAccessed || 0);
                    html += '<div class="restore-comparison">' +
                        '<div class="restore-local">' +
                            '<span>Local: ' + localProgress.percentage + '% (' + formatDate(localData.lastAccessed) + ')</span>' +
                        '</div>' +
                        '<div class="restore-imported">' +
                            '<span>Restore: ' + restoreProgress.percentage + '% (' + formatDate(restoreSet.lastWorkedOn) + ')</span>' +
                        '</div>' +
                        '<div class="restore-choice">' +
                            '<input type="radio" name="restore-' + restoreSet.fullNumber + '" id="restore-keep-' + restoreSet.fullNumber + '" value="keep" ' + (!restoreIsNewer ? 'checked' : '') + '>' +
                            '<label for="restore-keep-' + restoreSet.fullNumber + '" class="restore-choice-btn">Keep local</label>' +
                            '<input type="radio" name="restore-' + restoreSet.fullNumber + '" id="restore-import-' + restoreSet.fullNumber + '" value="import" ' + (restoreIsNewer ? 'checked' : '') + '>' +
                            '<label for="restore-import-' + restoreSet.fullNumber + '" class="restore-choice-btn">Overwrite</label>' +
                        '</div>' +
                    '</div>';
                } else {
                    html += '<div class="restore-new">' +
                        '<span>' + restoreProgress.percentage + '% complete (' + formatDate(restoreSet.lastWorkedOn) + ')</span>' +
                    '</div>';
                }

                itemEl.innerHTML = html;
                listEl.appendChild(itemEl);
            });

            document.getElementById('restoreModalOverlay').setAttribute('data-visible', '');
        }

        window.cancelRestore = function() {
            document.getElementById('restoreModalOverlay').removeAttribute('data-visible');
            pendingRestoreData = null;
        };

        window.executeRestore = function() {
            if (!pendingRestoreData) return;

            pendingRestoreData.sets.forEach(function(restoreSet) {
                var localData = getSetData(restoreSet.fullNumber);
                var hasConflict = !!localData;

                if (hasConflict) {
                    var radio = document.querySelector('input[name="restore-' + restoreSet.fullNumber + '"]:checked');
                    if (!radio || radio.value === 'keep') return;
                }

                // Build consolidated object from restore data
                var consolidated = {
                    number: restoreSet.info.number,
                    fullNumber: restoreSet.info.fullNumber,
                    name: restoreSet.info.name,
                    year: restoreSet.info.year,
                    numParts: restoreSet.info.numParts,
                    imageUrl: restoreSet.info.imageUrl,
                    lastAccessed: restoreSet.info.lastAccessed || restoreSet.lastWorkedOn,
                    progress: restoreSet.progress || ''
                };

                saveSetData(restoreSet.fullNumber, consolidated);
            });

            document.getElementById('restoreModalOverlay').removeAttribute('data-visible');
            pendingRestoreData = null;
            displaySetHistory();
        };

        // PWA file handler via launchQueue
        if ('launchQueue' in window) {
            window.launchQueue.setConsumer(function(launchParams) {
                if (!launchParams.files || !launchParams.files.length) return;
                launchParams.files[0].getFile().then(function(file) {
                    return file.text();
                }).then(function(text) {
                    var data = JSON.parse(text);
                    if (validateBricktally(data)) {
                        showRestoreDialog(data);
                    } else {
                        alert('Invalid .bricktally file');
                    }
                }).catch(function() {
                    alert('Invalid .bricktally file');
                });
            });
        }

        // ‚îÄ‚îÄ‚îÄ End Backup/Restore ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        function showSetHistory() {
            hide('setInfo', 'statsSection', 'filterSection', 'tableContainer', 'resetButton');
            // Clear table content and inline styles
            var tableContainer = document.getElementById('tableContainer');
            if (tableContainer) {
                tableContainer.innerHTML = '';
                tableContainer.style.display = 'none';
            }
            show('setHistorySection');
            displaySetHistory();
        }

        function hideSetHistory() {
            hide('setHistorySection');
        }

        function goToSetHistory() {
            // Clear current set
            currentSetNumber = '';
            localStorage.removeItem('currentSetNumber');
            document.getElementById('setNumber').value = '';

            // Reset all data
            partsData = [];
            userCounts = {};
            activeColorFilters = [];

            // Hide all set-related UI sections
            hide('setInfo', 'statsSection', 'filterSection', 'tableContainer', 'resetButton',
                 'partsSection', 'minifigSection', 'sparePartsSection');

            // Clear and hide spare table container
            var spareTableContainer = document.getElementById('spareTableContainer');
            if (spareTableContainer) {
                spareTableContainer.innerHTML = '';
                spareTableContainer.style.display = 'none';
            }

            // Remove has-set class from body
            document.body.classList.remove('has-set');

            // Show set history
            showSetHistory();
        }

        window.onload = function () {
            migrateLocalStorage();

            // Detect preview environment and add banner
            if (window.location.hostname === 'preview.bricktally.app') {
                document.title = 'BrickTally Preview';

                // Create preview banner
                var banner = document.createElement('div');
                banner.className = 'preview-banner';
                banner.textContent = 'PREVIEW';
                document.body.appendChild(banner);
            }

            // Load dark mode preference
            var darkMode = localStorage.getItem('darkMode');
            if (darkMode === 'true') {
                document.body.classList.add('dark-mode');
            }

            // Load show complete parts preference
            var savedShowComplete = localStorage.getItem('showCompleteParts');
            if (savedShowComplete === 'true') {
                showCompleteParts = true;
            }
            document.body.setAttribute('data-show-complete', showCompleteParts ? 'true' : 'false');

            // Update complete toggle button appearance
            // Toggle is ON (active) when HIDING complete parts (showCompleteParts = false)
            if (!showCompleteParts) {
                var completeToggle = document.getElementById('completeToggle');
                var completeToggleCollapsed = document.getElementById('completeToggleCollapsed');
                if (completeToggle) completeToggle.classList.add('active');
                if (completeToggleCollapsed) completeToggleCollapsed.classList.add('active');
            }

            // Load column preferences
            var savedColumns = localStorage.getItem('visibleColumns');
            if (savedColumns) {
                visibleColumns = JSON.parse(savedColumns);
                updateColumnToggles();
            }

            // Setup sticky header scroll behavior
            setupStickyHeader();

            // Setup lightbox event listeners
            var lightbox = document.getElementById('lightbox');
            var lightboxImage = document.getElementById('lightboxImage');
            var lightboxClose = document.getElementById('lightboxClose');
            var lightboxOriginRect = null;
            var lightboxOriginImage = null;

            // Function to open lightbox for an image
            function openLightbox(clickedImage) {
                var rect = clickedImage.getBoundingClientRect();

                // Store origin for close animation
                lightboxOriginRect = rect;
                lightboxOriginImage = clickedImage;

                // Hide the original image (keep its space)
                clickedImage.classList.add('lightbox-active');

                // Set the lightbox image source
                lightboxImage.src = clickedImage.src;
                lightboxImage.alt = clickedImage.alt;

                // Position the image at the clicked image's location and size
                lightboxImage.style.top = rect.top + 'px';
                lightboxImage.style.left = rect.left + 'px';
                lightboxImage.style.width = rect.width + 'px';
                lightboxImage.style.height = rect.height + 'px';
                lightboxImage.style.maxWidth = rect.width + 'px';
                lightboxImage.style.maxHeight = rect.height + 'px';
                lightboxImage.style.transform = 'translate(0, 0)';

                // Show lightbox
                lightbox.style.display = 'flex';

                // Force reflow
                lightboxImage.offsetHeight;

                // Animate to center
                requestAnimationFrame(function() {
                    lightbox.classList.add('active');
                    lightboxImage.style.top = '50%';
                    lightboxImage.style.left = '50%';
                    lightboxImage.style.width = '';
                    lightboxImage.style.height = '';
                    lightboxImage.style.maxWidth = '90%';
                    lightboxImage.style.maxHeight = '90%';
                    lightboxImage.style.transform = 'translate(-50%, -50%)';
                });
            }

            // Global function to open minifig lightbox
            window.openMinifigLightbox = function(img) {
                openLightbox(img);
            };

            // Event delegation for part images in table
            document.getElementById('tableContainer').addEventListener('click', function(e) {
                if (e.target.classList.contains('part-image')) {
                    openLightbox(e.target);
                }
            });

            // Event delegation for spare parts images in table
            document.getElementById('spareTableContainer').addEventListener('click', function(e) {
                if (e.target.classList.contains('part-image')) {
                    openLightbox(e.target);
                }
            });

            // Function to close lightbox
            function closeLightbox() {
                if (lightboxOriginRect) {
                    // Animate back to origin
                    lightbox.classList.remove('active');
                    lightboxImage.style.top = lightboxOriginRect.top + 'px';
                    lightboxImage.style.left = lightboxOriginRect.left + 'px';
                    lightboxImage.style.width = lightboxOriginRect.width + 'px';
                    lightboxImage.style.height = lightboxOriginRect.height + 'px';
                    lightboxImage.style.maxWidth = lightboxOriginRect.width + 'px';
                    lightboxImage.style.maxHeight = lightboxOriginRect.height + 'px';
                    lightboxImage.style.transform = 'translate(0, 0)';

                    setTimeout(function() {
                        lightbox.style.display = 'none';
                        // Restore original image visibility
                        if (lightboxOriginImage) {
                            lightboxOriginImage.classList.remove('lightbox-active');
                            lightboxOriginImage = null;
                        }
                        lightboxOriginRect = null;
                    }, 400);
                } else {
                    lightbox.classList.remove('active');
                    setTimeout(function() {
                        lightbox.style.display = 'none';
                    }, 300);
                }
            }

            // Close on X button
            lightboxClose.addEventListener('click', closeLightbox);

            // Close on background click
            lightbox.addEventListener('click', function(e) {
                if (e.target === lightbox) {
                    closeLightbox();
                }
            });

            // Close on ESC key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && lightbox.classList.contains('active')) {
                    closeLightbox();
                }
            });

            // Easter egg: long-press set image to launch memory game
            (function() {
                var longPressTimer = null;
                var startX = 0;
                var startY = 0;
                var container = document.getElementById('setImageContainer');

                container.addEventListener('pointerdown', function(e) {
                    startX = e.clientX;
                    startY = e.clientY;
                    longPressTimer = setTimeout(function() {
                        longPressTimer = null;
                        if (partsData.length > 0) startMemoryGame();
                    }, 1000);
                });

                container.addEventListener('pointermove', function(e) {
                    if (longPressTimer && (Math.abs(e.clientX - startX) > 10 || Math.abs(e.clientY - startY) > 10)) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                });

                container.addEventListener('pointerup', function() {
                    if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
                });

                container.addEventListener('pointercancel', function() {
                    if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
                });
            })();

            var urlSet = new URLSearchParams(window.location.search).get('set');
            var savedSetNumber = urlSet || localStorage.getItem('currentSetNumber');
            if (savedSetNumber) {
                // Extract base number without version suffix for display
                var baseNumber = savedSetNumber.split('-')[0];
                document.getElementById('setNumber').value = baseNumber;

                if (urlSet && !urlSet.includes('-')) {
                    // Deep link with bare number ‚Äî go through version search
                    loadSet();
                } else {
                    // Full version number from localStorage ‚Äî load directly
                    loadSetDirect(savedSetNumber);
                }
            } else {
                // Show set history if no current set
                showSetHistory();
            }
        };

        var headerScrollSetup = false; // Track if scroll listener is already set up

        function setupStickyHeader() {
            if (headerScrollSetup) return; // Prevent multiple listeners
            headerScrollSetup = true;

            window.addEventListener('scroll', function () {
                var currentScroll = window.pageYOffset || document.documentElement.scrollTop;
                var collapsedHeader = document.getElementById('collapsedHeader');
                var progressBar = document.getElementById('progressBar');
                var filterSection = document.getElementById('filterSection');

                // Prevent negative scroll values
                if (currentScroll < 0) {
                    currentScroll = 0;
                }

                // Calculate if progress bar is scrolled out of view
                if (progressBar) {
                    var progressBarRect = progressBar.getBoundingClientRect();
                    var progressBarBottom = progressBarRect.bottom;

                    // Show collapsed header when progress bar is scrolled past top
                    if (progressBarBottom < 0) {
                        document.body.setAttribute('data-collapsed-header', '');
                    } else {
                        document.body.removeAttribute('data-collapsed-header');
                    }
                }

                // Show/hide collapsed color filter when the whole color filter section is about to scroll out
                var colorFilterSection = document.getElementById('colorFilterSection');
                if (colorFilterSection && collapsedHeader) {
                    var colorFilterRect = colorFilterSection.getBoundingClientRect();
                    var colorFilterBottom = colorFilterRect.bottom;
                    var collapsedHeaderRect = collapsedHeader.getBoundingClientRect();
                    var collapsedHeaderBottom = collapsedHeaderRect.bottom;

                    var colorFilterCollapsed = document.getElementById('colorFilterCollapsed');

                    // Show collapsed color filter when bottom of color filter section scrolls under collapsed header
                    if (document.body.hasAttribute('data-collapsed-header') && colorFilterBottom < collapsedHeaderBottom) {
                        if (colorFilterCollapsed && !colorFilterCollapsed.classList.contains('visible')) {
                            colorFilterCollapsed.classList.remove('hide');
                            // Force reflow to ensure display:block is applied before transition
                            colorFilterCollapsed.offsetHeight;
                            requestAnimationFrame(function() {
                                colorFilterCollapsed.classList.add('visible');
                            });
                        }
                    } else {
                        if (colorFilterCollapsed && colorFilterCollapsed.classList.contains('visible')) {
                            colorFilterCollapsed.classList.remove('visible');
                            // Delay adding hide class to allow animation to complete
                            setTimeout(function() {
                                colorFilterCollapsed.classList.add('hide');
                            }, 500);
                        }
                    }
                }

                // Show/hide collapsed info filter when the whole show information section is about to scroll out
                var showInformationSection = document.getElementById('columnsFilterSection');
                if (showInformationSection && collapsedHeader) {
                    var showInfoRect = showInformationSection.getBoundingClientRect();
                    var showInfoBottom = showInfoRect.bottom;
                    var collapsedHeaderRect = collapsedHeader.getBoundingClientRect();
                    var collapsedHeaderBottom = collapsedHeaderRect.bottom;

                    var infoFilterCollapsed = document.getElementById('infoFilterCollapsed');

                    // Show collapsed info filter when bottom of show information section scrolls under collapsed header
                    if (document.body.hasAttribute('data-collapsed-header') && showInfoBottom < collapsedHeaderBottom) {
                        if (infoFilterCollapsed && !infoFilterCollapsed.classList.contains('visible')) {
                            infoFilterCollapsed.classList.remove('hide');
                            // Force reflow to ensure display:block is applied before transition
                            infoFilterCollapsed.offsetHeight;
                            requestAnimationFrame(function() {
                                infoFilterCollapsed.classList.add('visible');
                            });
                        }
                    } else {
                        if (infoFilterCollapsed && infoFilterCollapsed.classList.contains('visible')) {
                            infoFilterCollapsed.classList.remove('visible');
                            // Delay adding hide class to allow animation to complete
                            setTimeout(function() {
                                infoFilterCollapsed.classList.add('hide');
                            }, 500);
                        }
                    }
                }
            }, { passive: true });
        }

        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            var isDark = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDark);
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
                // Enter fullscreen
                var elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.mozRequestFullScreen) {
                    elem.mozRequestFullScreen();
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen();
                }
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        // Update fullscreen icon when fullscreen state changes
        document.addEventListener('fullscreenchange', updateFullscreenIcon);
        document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);
        document.addEventListener('mozfullscreenchange', updateFullscreenIcon);
        document.addEventListener('msfullscreenchange', updateFullscreenIcon);

        function updateFullscreenIcon() {
            var isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
            var fullscreenIcon = document.getElementById('fullscreenIcon');
            // When in fullscreen, show X to exit
            // When not in fullscreen, show expand icon to enter
            fullscreenIcon.textContent = isFullscreen ? '‚úï' : '‚õ∂';
        }

        // Memory Game (Easter Egg)
        function shuffleArray(arr) {
            for (var i = arr.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
            return arr;
        }

        function startMemoryGame() {
            // Collect unique images
            var seen = {};
            var candidates = [];
            for (var i = 0; i < partsData.length; i++) {
                var p = partsData[i];
                if (p.imageUrl && !seen[p.imageUrl]) {
                    seen[p.imageUrl] = true;
                    candidates.push(p);
                }
            }

            if (candidates.length < 6) return;

            shuffleArray(candidates);
            // Scale pairs based on set size
            var totalParts = partsData.length;
            var maxPairs = totalParts <= 30 ? 6 : totalParts <= 60 ? 8 : totalParts <= 150 ? 10 : 12;
            var pairCount = Math.min(maxPairs, candidates.length);
            var selected = candidates.slice(0, pairCount);

            // Create pairs
            var cards = [];
            for (var i = 0; i < selected.length; i++) {
                cards.push({ imageUrl: selected[i].imageUrl, pairId: i });
                cards.push({ imageUrl: selected[i].imageUrl, pairId: i });
            }
            shuffleArray(cards);

            // Game state
            var flipped = [];
            var matched = {};
            var moves = 0;
            var locked = false;
            var totalPairs = selected.length;

            // Build overlay
            var overlay = document.createElement('div');
            overlay.className = 'memory-overlay';

            var modal = document.createElement('div');
            modal.className = 'memory-modal';

            // Header
            var header = document.createElement('div');
            header.className = 'memory-header';
            header.innerHTML = '<span class="memory-title">\uD83E\uDDE9 Memory Game</span><span class="memory-moves">Moves: <span id="memoryMoveCount">0</span></span>';

            var closeBtn = document.createElement('button');
            closeBtn.className = 'memory-close';
            closeBtn.textContent = '\u2715';
            closeBtn.onclick = function() { overlay.remove(); };
            header.appendChild(closeBtn);
            modal.appendChild(header);

            // Grid
            var grid = document.createElement('div');
            grid.className = 'memory-grid';
            var cols = cards.length <= 12 ? 3 : cards.length <= 16 ? 4 : 4;
            grid.style.gridTemplateColumns = 'repeat(' + cols + ', 1fr)';

            var cardElements = [];
            for (var i = 0; i < cards.length; i++) {
                (function(index) {
                    var card = document.createElement('div');
                    card.className = 'memory-card';

                    var inner = document.createElement('div');
                    inner.className = 'memory-card-inner';

                    var back = document.createElement('div');
                    back.className = 'memory-card-back';
                    back.textContent = '\uD83E\uDDF1';

                    var front = document.createElement('div');
                    front.className = 'memory-card-front';
                    var img = document.createElement('img');
                    img.src = cards[index].imageUrl;
                    img.alt = 'Part';
                    img.onerror = function() {
                        this.style.display = 'none';
                        front.textContent = '?';
                        front.style.fontSize = '28px';
                        front.style.display = 'flex';
                        front.style.alignItems = 'center';
                        front.style.justifyContent = 'center';
                    };
                    front.appendChild(img);

                    inner.appendChild(back);
                    inner.appendChild(front);
                    card.appendChild(inner);

                    card.onclick = function() {
                        if (locked || matched[index] || flipped.indexOf(index) !== -1) return;

                        card.classList.add('flipped');
                        flipped.push(index);

                        if (flipped.length === 2) {
                            moves++;
                            document.getElementById('memoryMoveCount').textContent = moves;

                            var idx1 = flipped[0];
                            var idx2 = flipped[1];

                            if (cards[idx1].pairId === cards[idx2].pairId) {
                                // Match
                                matched[idx1] = true;
                                matched[idx2] = true;
                                cardElements[idx1].classList.add('matched');
                                cardElements[idx2].classList.add('matched');
                                flipped = [];

                                // Check win
                                if (Object.keys(matched).length === cards.length) {
                                    setTimeout(function() { showWin(); }, 600);
                                }
                            } else {
                                // No match
                                locked = true;
                                setTimeout(function() {
                                    cardElements[idx1].classList.remove('flipped');
                                    cardElements[idx2].classList.remove('flipped');
                                    flipped = [];
                                    locked = false;
                                }, 800);
                            }
                        }
                    };

                    cardElements.push(card);
                    grid.appendChild(card);
                })(i);
            }

            modal.appendChild(grid);

            // Win message container
            var winMsg = document.createElement('div');
            winMsg.id = 'memoryWinMsg';
            winMsg.className = 'memory-win hide';
            modal.appendChild(winMsg);

            overlay.appendChild(modal);
            document.body.appendChild(overlay);

            // Close on Escape
            function onEscape(e) {
                if (e.key === 'Escape') {
                    overlay.remove();
                    document.removeEventListener('keydown', onEscape);
                }
            }
            document.addEventListener('keydown', onEscape);

            // Close on overlay click
            overlay.onclick = function(e) {
                if (e.target === overlay) overlay.remove();
            };

            function showWin() {
                winMsg.classList.remove('hide');
                winMsg.innerHTML = '<div class="memory-win-text">\uD83C\uDF89 You won!</div>' +
                    '<div class="memory-win-stats">' + totalPairs + ' pairs in ' + moves + ' moves</div>' +
                    '<button class="memory-play-again">Play Again</button>';
                winMsg.querySelector('.memory-play-again').addEventListener('click', function() {
                    overlay.remove();
                    startMemoryGame();
                });
            }
        }

        // Filter accordion: only one section open at a time
        document.querySelectorAll('.filter-section').forEach(function(details) {
            details.addEventListener('toggle', function() {
                if (details.open) {
                    document.querySelectorAll('.filter-section').forEach(function(other) {
                        if (other !== details) other.removeAttribute('open');
                    });
                }
            });
        });

        function toggleColumn(column, event) {
            if (event) {
                event.stopPropagation();
            }
            visibleColumns[column] = !visibleColumns[column];
            localStorage.setItem('visibleColumns', JSON.stringify(visibleColumns));
            renderTable();
            renderSparePartsTable();
        }

        function updateColumnToggles() {
            var toggles = document.querySelectorAll('.column-toggle');
            toggles.forEach(function (toggle) {
                var text = toggle.textContent.toLowerCase().trim();
                var column = '';

                if (text.includes('part number')) {
                    column = 'partNum';
                } else if (text.includes('name')) {
                    column = 'name';
                } else if (text.includes('color')) {
                    column = 'color';
                }

                if (column && visibleColumns[column]) {
                    toggle.classList.add('active');
                } else if (column) {
                    toggle.classList.remove('active');
                }
            });
        }


        function updateMinifigHeader() {
            var header = document.getElementById('minifigHeader');
            if (!header) return;

            // Check if all minifigs are complete
            var minifigs = partsData.filter(function(item) {
                return item.type === 'minifig';
            });

            if (minifigs.length === 0) {
                header.textContent = 'Minifigures';
                return;
            }

            var allComplete = minifigs.every(function(minifig) {
                var key = getPartKey(minifig);
                return (userCounts[key] || 0) === minifig.quantity;
            });

            // Show checkmark only when hide complete is ON and all minifigs are complete
            if (!showCompleteParts && allComplete) {
                header.innerHTML = 'Minifigures <span style="color: var(--green);">‚úì</span>';
            } else {
                header.textContent = 'Minifigures';
            }
        }

        function updatePartsHeader() {
            var header = document.getElementById('partsHeader');
            if (!header) return;

            // Check if all regular parts are complete
            var regularParts = partsData.filter(function(item) {
                return !item.isSpare && item.type !== 'minifig';
            });

            if (regularParts.length === 0) {
                header.textContent = 'Parts';
                return;
            }

            var allComplete = regularParts.every(function(part) {
                var regularKey = getPartKey(part);
                var spareKey = regularKey + '_s';
                var regularCount = userCounts[regularKey] || 0;
                var spareCount = userCounts[spareKey] || 0;
                var combinedCount = regularCount + spareCount;
                return combinedCount >= part.quantity;
            });

            // Show checkmark only when hide complete is ON and all parts are complete
            if (!showCompleteParts && allComplete) {
                header.innerHTML = 'Parts <span style="color: var(--green);">‚úì</span>';
            } else {
                header.textContent = 'Parts';
            }
        }

        function updateSparePartsHeader() {
            var header = document.getElementById('sparePartsHeader');
            if (!header) return;

            // Check if all spare parts are complete
            var spareParts = partsData.filter(function(item) {
                return item.isSpare;
            });

            if (spareParts.length === 0) {
                header.textContent = 'Spare Parts';
                return;
            }

            var allComplete = spareParts.every(function(spare) {
                var key = getPartKey(spare);
                return (userCounts[key] || 0) === spare.quantity;
            });

            // Show checkmark only when hide complete is ON and all spare parts are complete
            if (!showCompleteParts && allComplete) {
                header.innerHTML = 'Spare Parts <span style="color: var(--green);">‚úì</span>';
            } else {
                header.textContent = 'Spare Parts';
            }
        }

        function placeCompleteToggle() {
            var toggle = document.getElementById('completeToggleContainer');
            if (!toggle) return;

            // Find the first visible section in order: minifig, parts, spare parts
            var sections = ['minifigSection', 'partsSection', 'sparePartsSection'];
            for (var i = 0; i < sections.length; i++) {
                var section = document.getElementById(sections[i]);
                if (section && !section.classList.contains('hide')) {
                    var headerRow = section.querySelector('.section-header-row');
                    if (headerRow) {
                        headerRow.appendChild(toggle);
                        toggle.style.display = '';
                        return;
                    }
                }
            }
        }

        function toggleCompleteParts() {
            showCompleteParts = !showCompleteParts;
            localStorage.setItem('showCompleteParts', showCompleteParts);
            document.body.setAttribute('data-show-complete', showCompleteParts ? 'true' : 'false');

            // Update button appearance for both toggles
            // Note: toggle is ON (active) when HIDING complete parts (showCompleteParts = false)
            ['completeToggle', 'completeToggleCollapsed'].forEach(function(id) {
                var button = document.getElementById(id);
                if (button) {
                    if (!showCompleteParts) {
                        button.classList.add('active');
                    } else {
                        button.classList.remove('active');
                    }
                }
            });

            // CSS handles row/card visibility via body[data-show-complete] + [data-complete]
            // Only need to update header counts
            updateMinifigHeader();
            updatePartsHeader();
            updateSparePartsHeader();
        }

        function updateTableVisibility() {
            // Completion visibility is handled by CSS via body[data-show-complete] + tr[data-complete]
            // This function only handles color filtering
            partsData.forEach(function (part) {
                if (part.type === 'minifig') return; // minifigs don't have color filters

                var row = document.getElementById('row-' + part.id);
                if (!row) return;

                var colorMatch = activeColorFilters.length === 0 || activeColorFilters.indexOf(part.color) > -1;
                if (!colorMatch) {
                    row.setAttribute('data-color-hidden', '');
                } else {
                    row.removeAttribute('data-color-hidden');
                }
            });
        }

        function loadSetVersions(setNumberBase) {
            // Remove any existing suffix to get base number
            var baseNumber = setNumberBase.split('-')[0];

            return fetchWithRetry('/api/rebrickable?endpoint=/lego/sets/&search=' + encodeURIComponent(baseNumber))
                .then(function (response) {
                    return response.json();
                })
                .then(function (data) {
                    // Filter results to only exact matches with this base number
                    var versions = data.results.filter(function (set) {
                        return set.set_num.startsWith(baseNumber + '-');
                    });
                    return versions;
                });
        }

        function loadSetDirect(setNumber) {
            show('loading');
            hide('error', 'tableContainer', 'statsSection', 'setInfo', 'filterSection', 'resetButton');
            document.getElementById('tableContainer').innerHTML = '';

            continueLoadSet(setNumber);
        }

        function loadSet() {
            var setNumber = document.getElementById('setNumber').value.trim();

            if (!setNumber) {
                showError('Please enter a set number');
                return;
            }

            show('loading');
            hide('error', 'tableContainer', 'statsSection', 'setInfo', 'filterSection', 'resetButton');
            document.getElementById('tableContainer').innerHTML = '';

            var baseNumber = setNumber.split('-')[0];

            // First check for multiple versions
            loadSetVersions(baseNumber)
                .then(function (versions) {
                    if (versions.length > 1) {
                        // Multiple versions exist - show selector
                        showVersionSelector(versions);
                        hide('loading');
                    } else {
                        // Single version - proceed normally
                        var finalSetNumber = setNumber.includes('-') ? setNumber : setNumber + '-1';
                        continueLoadSet(finalSetNumber);
                    }
                })
                .catch(function (error) {
                    // If version check fails, try with -1 suffix
                    var finalSetNumber = setNumber.includes('-') ? setNumber : setNumber + '-1';
                    continueLoadSet(finalSetNumber);
                });
        }

        function continueLoadSet(setNumber) {
            hideSetHistory();

            fetchWithRetry('/api/rebrickable?endpoint=/lego/sets/' + encodeURIComponent(setNumber) + '/')
                .then(function (response) {
                    return response.json();
                })
                .then(function (setData) {
                    currentSetNumber = setNumber;
                    localStorage.setItem('currentSetNumber', setNumber);
                    displaySetInfo(setData);
                    return Promise.all([loadAllParts(setNumber), loadMinifigures(setNumber)]);
                })
                .then(function (results) {
                    var allParts = results[0];
                    var minifigs = results[1];

                    if (!allParts || allParts.length === 0) {
                        throw new Error('No parts found for this set');
                    }
                    processParts(allParts, minifigs);
                })
                .catch(function (error) {
                    console.error('[BrickTally:API] Error:', error);
                    showError(error.message || 'Error loading set data. Please try again.');
                })
                .finally(function () {
                    hide('loading');
                });
        }

        function showVersionSelector(versions) {
            var modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 20px;';

            var content = document.createElement('div');
            content.style.cssText = 'background: var(--bg-secondary); padding: 30px; border-radius: 8px; max-width: 600px; width: 100%; max-height: 80vh; overflow-y: auto;';

            var html = '<h2 style="margin-bottom: 20px; color: var(--text-primary);">Multiple Set Versions Found</h2>' +
                '<p style="margin-bottom: 20px; color: var(--text-secondary);">This set has ' + versions.length + ' versions. Please select one:</p>' +
                '<div style="display: flex; flex-direction: column; gap: 15px;">';

            versions.forEach(function (version) {
                var imgUrl = version.set_img_url || 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="100" height="80"%3E%3Crect width="100" height="80" fill="%23ddd"/%3E%3Ctext x="50%25" y="50%25" dominant-baseline="middle" text-anchor="middle" font-family="Arial" font-size="12" fill="%23999"%3ENo Image%3C/text%3E%3C/svg%3E';
                html += '<button onclick="selectVersion(\'' + version.set_num + '\')" style="' +
                    'display: flex; align-items: center; gap: 15px; padding: 15px; ' +
                    'background: var(--bg-tertiary); border: 2px solid var(--border-color); ' +
                    'border-radius: 8px; cursor: pointer; text-align: left; width: 100%;">' +
                    '<img src="' + imgUrl + '" style="width: 100px; height: 80px; object-fit: contain; border-radius: 4px;" class="version-selector-image" onerror="handleImageError(this)" onclick="event.stopPropagation(); retryImageLoad(this);">' +
                    '<div style="flex: 1;">' +
                    '<div style="font-weight: bold; color: var(--text-primary); margin-bottom: 5px;">' + version.name + '</div>' +
                    '<div style="color: var(--text-secondary); font-size: 14px;">Set: ' + version.set_num + ' | Year: ' + version.year + ' | Parts: ' + version.num_parts + '</div>' +
                    '</div>' +
                    '</button>';
            });

            html += '</div>' +
                '<button onclick="this.parentElement.parentElement.remove()" style="margin-top: 20px; width: 100%; background: var(--text-secondary);">Cancel</button>';

            content.innerHTML = html;
            modal.appendChild(content);
            document.body.appendChild(modal);

            modal.onclick = function (e) {
                if (e.target === modal) modal.remove();
            };
        }

        function selectVersion(setNumber) {
            // Close modal
            var modals = document.querySelectorAll('body > div');
            modals.forEach(function (modal) {
                if (modal.style.position === 'fixed') {
                    modal.remove();
                }
            });

            // Update input field to show selected version
            document.getElementById('setNumber').value = setNumber.split('-')[0];

            // Load the selected version
            show('loading');
            continueLoadSet(setNumber);
        }

        function fetchWithRetry(url, retries, delay) {
            retries = retries || 3;
            delay = delay || 1000;
            return fetch(url).then(function (response) {
                if (response.status === 429 && retries > 0) {
                    console.warn('[BrickTally:API] Rate limited, retrying in ' + delay + 'ms...');
                    return new Promise(function (resolve) {
                        setTimeout(resolve, delay);
                    }).then(function () {
                        return fetchWithRetry(url, retries - 1, delay * 2);
                    });
                }
                if (!response.ok) throw new Error('API error (HTTP ' + response.status + ')');
                return response;
            });
        }

        function loadAllParts(setNumber) {
            var allParts = [];

            function fetchPage(page) {
                return fetchWithRetry('/api/rebrickable?endpoint=/lego/sets/' + encodeURIComponent(setNumber) + '/parts/&page_size=1000&page=' + page)
                    .then(function (response) {
                        return response.json();
                    })
                    .then(function (data) {
                        if (data.results && data.results.length > 0) {
                            allParts = allParts.concat(data.results);
                        }

                        if (data.next) {
                            return fetchPage(page + 1);
                        } else {
                            return allParts;
                        }
                    });
            }

            return fetchPage(1);
        }

        function loadMinifigures(setNumber) {
            return fetchWithRetry('/api/rebrickable?endpoint=/lego/sets/' + encodeURIComponent(setNumber) + '/minifigs/')
                .then(function (response) {
                    return response.json();
                })
                .then(function (data) {
                    return data.results || [];
                })
                .catch(function (error) {
                    console.warn('Minifigures unavailable:', error);
                    return [];  // Continue gracefully if minifigs unavailable
                });
        }

        function displaySetInfo(setData) {
            var setImageUrl = setData.set_img_url || 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="300" height="200"%3E%3Crect width="300" height="200" fill="%23ddd"/%3E%3Ctext x="50%25" y="50%25" dominant-baseline="middle" text-anchor="middle" font-family="Arial" font-size="16" fill="%23999"%3ENo Image%3C/text%3E%3C/svg%3E';
            var versionParts = currentSetNumber.split('-');
            var versionNumber = versionParts[1];
            var displaySetNumber = versionParts[0]; // Show without suffix
            var versionInfo = versionNumber !== '1' ?
                ' <span style="color: var(--orange);">(Version ' + versionNumber + ')</span>' : '';

            document.getElementById('setName').textContent = setData.name;
            document.getElementById('setImageContainer').innerHTML =
                '<img src="' + setImageUrl + '" alt="' + setData.name + '" class="set-detail-image" onerror="handleImageError(this)" onclick="retryImageLoad(this)">';
            document.getElementById('setDetails').innerHTML =
                'Set Number: ' + displaySetNumber + versionInfo + ' | Year: ' + setData.year + ' | Parts: ' + setData.num_parts;

            // Update collapsed header set name
            var collapsedVersionInfo = versionNumber !== '1' ? ' (v' + versionNumber + ')' : '';
            document.getElementById('collapsedSetName').textContent = displaySetNumber + ': ' + setData.name + collapsedVersionInfo;

            // Save set info for set history
            saveSetInfo(currentSetNumber, setData);

            show('setInfo');
        }

        function processParts(results, minifigs) {
            partsData = results.map(function (item, index) {
                return {
                    id: index,
                    type: 'part',
                    partNum: item.part.part_num || 'unknown',
                    name: item.part.name || 'Unknown Part',
                    color: (item.color && item.color.name) ? item.color.name : 'Unknown',
                    colorId: (item.color && item.color.id) ? item.color.id : 0,
                    quantity: item.quantity || 0,
                    imageUrl: item.part.part_img_url || 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="80" height="80"%3E%3Crect width="80" height="80" fill="%23ddd"/%3E%3Ctext x="50%25" y="50%25" dominant-baseline="middle" text-anchor="middle" font-family="Arial" font-size="10" fill="%23999"%3ENo Image%3C/text%3E%3C/svg%3E',
                    isSpare: item.is_spare || false
                };
            });

            // Transform and merge minifigs
            var minifigsData = (minifigs || []).map(function(item) {
                return {
                    id: item.id,  // Use the API's unique ID
                    type: 'minifig',
                    partNum: item.set_num,
                    name: item.set_name || 'Unknown Minifig',
                    color: '',
                    colorId: 0,
                    quantity: item.quantity,
                    imageUrl: item.set_img_url || 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="80" height="80"%3E%3Crect width="80" height="80" fill="%23ddd"/%3E%3Ctext x="50%25" y="50%25" dominant-baseline="middle" text-anchor="middle" font-family="Arial" font-size="10" fill="%23999"%3ENo Image%3C/text%3E%3C/svg%3E',
                    isSpare: false,
                    numParts: item.num_parts || 0
                };
            });

            partsData = partsData.concat(minifigsData);

            userCounts = {};
            partsData.forEach(function (part) {
                var key = getPartKey(part);
                userCounts[key] = 0;
            });

            loadState();
            renderColorFilters();
            renderMinifigures();
            renderTable();
            renderSparePartsTable();
            updateTableVisibility();
            updateMinifigHeader();
            updatePartsHeader();
            updateSparePartsHeader();
            show('statsSection', 'filterSection', 'resetButton', 'partsSection');
            placeCompleteToggle();
            document.body.classList.add('has-set');

            updateStats();
            wasComplete = false;
        }

        function renderColorFilters() {
            var colorCounts = {};

            partsData.forEach(function (part) {
                // Skip minifigs and spare parts in filter counts
                if (part.type === 'minifig' || part.isSpare) return;

                if (!colorCounts[part.color]) {
                    colorCounts[part.color] = 0;
                }
                colorCounts[part.color] += part.quantity;
            });

            var totalPieces = 0;
            for (var color in colorCounts) {
                totalPieces += colorCounts[color];
            }

            var html = '<button class="filter active" onclick="toggleColorFilter(\'all\')">All <span class="count">(' + totalPieces + ')</span></button>';

            Object.keys(colorCounts).sort().forEach(function (color) {
                html += '<button class="filter" onclick="toggleColorFilter(\'' + color.replace(/'/g, "\\'") + '\')">' +
                    color + ' <span class="count">(' + colorCounts[color] + ')</span></button>';
            });

            // Render in both locations
            document.getElementById('colorFilters').innerHTML = html;
            document.getElementById('colorFiltersCollapsed').innerHTML = html;
            activeColorFilters = [];
        }

        function toggleColorFilter(color) {
            var buttons = document.querySelectorAll('.filter');

            if (color === 'all') {
                activeColorFilters = [];
                buttons.forEach(function (btn) { btn.classList.remove('active'); });
                buttons[0].classList.add('active');
            } else {
                buttons[0].classList.remove('active');

                var index = activeColorFilters.indexOf(color);
                if (index > -1) {
                    activeColorFilters.splice(index, 1);
                    event.target.classList.remove('active');
                } else {
                    activeColorFilters.push(color);
                    event.target.classList.add('active');
                }

                if (activeColorFilters.length === 0) {
                    buttons[0].classList.add('active');
                }
            }

            filterTable();
        }

        function filterTable() {
            updateTableVisibility();
        }

        function renderTable() {
            var html = '<table><tbody>';

            partsData.forEach(function (part) {
                // Skip minifigs and spare parts
                if (part.type === 'minifig' || part.isSpare) return;

                var key = getPartKey(part);
                var currentCount = userCounts[key] || 0;
                var isComplete = currentCount === part.quantity;

                // Build combined info column content based on visible columns
                var infoContent = [];

                if (visibleColumns.color) {
                    infoContent.push(part.color);
                }

                if (visibleColumns.name) {
                    infoContent.push(part.name);
                }

                // Build the info text
                var infoText = infoContent.join(' ');

                // Add part number on a new line if enabled (only add <br> if there's content before it)
                if (visibleColumns.partNum) {
                    if (infoText) {
                        infoText += '<br>' + part.partNum;
                    } else {
                        infoText = part.partNum;
                    }
                }

                // If nothing is selected, show at least the image
                if (!visibleColumns.color && !visibleColumns.name && !visibleColumns.partNum) {
                    infoText = '&nbsp;';
                }

                // Show checkmark when complete or one piece remaining, otherwise show +
                var remaining = part.quantity - currentCount;
                var incrementButtonText = (isComplete || remaining <= 1) ? '‚úì' : '+';
                var incrementBtnClass = isComplete ? ' complete' : '';
                var incrementBtnDisabled = isComplete ? ' disabled' : '';

                var altText = (part.color + ' ' + part.name + ' (' + part.partNum + ')').replace(/"/g, '&quot;');
                var fallbackInfo = part.color + ' ' + part.name + '<br>' + part.partNum;
                var decrementHidden = currentCount === 0 ? ' data-hidden-when-zero' : '';
                html += '<tr id="row-' + part.id + '" data-complete="' + isComplete + '" data-color="' + part.color + '" data-fallback-info="' + fallbackInfo.replace(/"/g, '&quot;') + '">' +
                    '<td class="col-img"><img src="' + part.imageUrl + '" alt="' + altText + '" class="part-image" data-part-id="' + part.id + '" onerror="handleImageError(this)" onload="handleImageLoad(this)"></td>' +
                    '<td class="col-info" id="info-' + part.id + '">' + infoText + '</td>' +
                    '<td class="col-controls"><div class="controls">' +
                    '<button id="dec-' + part.id + '" onclick="decrementPart(' + part.id + ')"' + decrementHidden + '>-</button>' +
                    '<span class="count-display" id="count-' + part.id + '"><span class="counted">' + currentCount + '</span>/<span class="qty-click" onclick="fillQuantity(' + part.id + ')" title="Click to mark all as counted">' + part.quantity + '</span></span>' +
                    '<button id="inc-' + part.id + '" class="increment-btn' + incrementBtnClass + '" onclick="incrementPart(' + part.id + ')"' + incrementBtnDisabled + '>' + incrementButtonText + '</button>' +
                    '</div></td></tr>';
            });

            html += '</tbody></table>';
            document.getElementById('tableContainer').innerHTML = html;
            document.getElementById('tableContainer').style.display = 'block';

            // Update column toggle states
            updateColumnToggles();
        }

        function renderSparePartsTable() {
            var spareParts = partsData.filter(function(part) {
                return part.isSpare;
            });

            if (spareParts.length === 0) {
                hide('sparePartsSection');
                document.getElementById('spareTableContainer').style.display = 'none';
                return;
            }

            var html = '<table><tbody>';

            spareParts.forEach(function (part) {
                var key = getPartKey(part);
                var currentCount = userCounts[key] || 0;
                var isComplete = currentCount === part.quantity;

                // Build combined info column content based on visible columns
                var infoContent = [];

                if (visibleColumns.color) {
                    infoContent.push(part.color);
                }

                if (visibleColumns.name) {
                    infoContent.push(part.name);
                }

                // Build the info text
                var infoText = infoContent.join(' ');

                // Add part number on a new line if enabled
                if (visibleColumns.partNum) {
                    if (infoText) {
                        infoText += '<br>' + part.partNum;
                    } else {
                        infoText = part.partNum;
                    }
                }

                // If nothing is selected, show at least the image
                if (!visibleColumns.color && !visibleColumns.name && !visibleColumns.partNum) {
                    infoText = '&nbsp;';
                }

                // Show checkmark when complete or one piece remaining, otherwise show +
                var remaining = part.quantity - currentCount;
                var incrementButtonText = (isComplete || remaining <= 1) ? '‚úì' : '+';
                var incrementBtnClass = isComplete ? ' complete' : '';
                var incrementBtnDisabled = isComplete ? ' disabled' : '';

                var altText = (part.color + ' ' + part.name + ' (' + part.partNum + ')').replace(/"/g, '&quot;');
                var fallbackInfo = part.color + ' ' + part.name + '<br>' + part.partNum;
                var decrementHidden = currentCount === 0 ? ' data-hidden-when-zero' : '';
                html += '<tr id="row-' + part.id + '" data-complete="' + isComplete + '" data-color="' + part.color + '" data-fallback-info="' + fallbackInfo.replace(/"/g, '&quot;') + '">' +
                    '<td class="col-img"><img src="' + part.imageUrl + '" alt="' + altText + '" class="part-image" data-part-id="' + part.id + '" onerror="handleImageError(this)" onload="handleImageLoad(this)"></td>' +
                    '<td class="col-info" id="info-' + part.id + '">' + infoText + '</td>' +
                    '<td class="col-controls"><div class="controls">' +
                    '<button id="dec-' + part.id + '" onclick="decrementPart(' + part.id + ')"' + decrementHidden + '>-</button>' +
                    '<span class="count-display" id="count-' + part.id + '"><span class="counted">' + currentCount + '</span>/<span class="qty-click" onclick="fillQuantity(' + part.id + ')" title="Click to mark all as counted">' + part.quantity + '</span></span>' +
                    '<button id="inc-' + part.id + '" class="increment-btn' + incrementBtnClass + '" onclick="incrementPart(' + part.id + ')"' + incrementBtnDisabled + '>' + incrementButtonText + '</button>' +
                    '</div></td></tr>';
            });

            html += '</tbody></table>';
            document.getElementById('spareTableContainer').innerHTML = html;
            document.getElementById('spareTableContainer').style.display = 'block';
            show('sparePartsSection');
        }

        function renderMinifigures() {
            var minifigs = partsData.filter(function(item) {
                return item.type === 'minifig';
            });

            if (minifigs.length === 0) {
                hide('minifigSection');
                return;
            }

            var html = '<div class="minifig-grid">';

            minifigs.forEach(function(minifig) {
                var key = getPartKey(minifig);
                var currentCount = userCounts[key] || 0;
                var isComplete = currentCount === minifig.quantity;
                // Parse name: Try " - " first, then ", " as delimiter
                var nameParts = minifig.name.split(' - ');
                var title, description;

                if (nameParts.length > 1) {
                    // Found " - " delimiter
                    title = nameParts[0];
                    description = nameParts.slice(1).join(' - ');
                } else {
                    // Try ", " delimiter
                    nameParts = minifig.name.split(', ');
                    if (nameParts.length > 1) {
                        title = nameParts[0];
                        description = nameParts.slice(1).join(', ');
                    } else {
                        // No delimiter found, use full name as title
                        title = minifig.name;
                        description = '';
                    }
                }

                html += '<div class="minifig-card' + (isComplete ? ' complete' : '') + '" data-complete="' + isComplete + '" id="minifig-' + minifig.id + '" onclick="toggleMinifig(' + minifig.id + ')">' +
                    '<img src="' + minifig.imageUrl + '" alt="' + minifig.name + '" class="minifig-image" data-part-id="' + minifig.id + '" onclick="event.stopPropagation(); openMinifigLightbox(this)" onerror="handleImageError(this)" onload="handleImageLoad(this)">' +
                    '<div class="minifig-name">' + title + '</div>' +
                    '<div class="minifig-id">' + description + '</div>' +
                '</div>';
            });

            html += '</div>';

            document.getElementById('minifigContainer').innerHTML = html;
            show('minifigSection');
        }

        function updateCorrespondingPart(sparePart) {
            // Find the regular part with same partNum and color
            var regularPart = partsData.find(function(p) {
                return !p.isSpare && p.partNum === sparePart.partNum && p.color === sparePart.color;
            });
            if (regularPart) {
                updateRow(regularPart.id);
            }
        }

        function updateCorrespondingSpare(regularPart) {
            // Find the spare part with same partNum and color
            var sparePart = partsData.find(function(p) {
                return p.isSpare && p.partNum === regularPart.partNum && p.color === regularPart.color;
            });
            if (sparePart) {
                updateRow(sparePart.id);
            }
        }

        function toggleMinifig(partId) {
            var part = partsData.find(function(p) { return p.id === partId; });
            if (!part || part.type !== 'minifig') return;

            var key = getPartKey(part);
            // Toggle between 0 and 1
            userCounts[key] = userCounts[key] === 1 ? 0 : 1;
            updateRow(partId);
            updateStats();
            updateTableVisibility();
            updateMinifigHeader();
            checkAndCelebrate();
            saveState();
        }

        function incrementPart(partId) {
            var part = partsData[partId];
            if (!part) return;

            var key = getPartKey(part);
            if (userCounts[key] >= part.quantity) return;

            userCounts[key]++;
            updateRow(partId);

            // If this is a spare part, also update the corresponding regular part
            if (part.isSpare) {
                updateCorrespondingPart(part);
            }
            // If this is a regular part, update its spare (if exists)
            else {
                updateCorrespondingSpare(part);
            }

            updateStats();
            updatePartsHeader();
            updateSparePartsHeader();
            checkAndCelebrate();
            saveState();
        }

        function decrementPart(partId) {
            var part = partsData[partId];
            if (!part) return;

            var key = getPartKey(part);
            if (userCounts[key] <= 0) return;

            userCounts[key]--;
            updateRow(partId);

            // If this is a spare part, also update the corresponding regular part
            if (part.isSpare) {
                updateCorrespondingPart(part);
            }
            // If this is a regular part, update its spare (if exists)
            else {
                updateCorrespondingSpare(part);
            }

            updateStats();
            updatePartsHeader();
            updateSparePartsHeader();
            checkAndCelebrate();
            saveState();
        }

        function fillQuantity(partId) {
            var part = partsData[partId];
            if (!part) return;

            var key = getPartKey(part);
            // Set the count to the full quantity
            userCounts[key] = part.quantity;
            updateRow(partId);

            // If this is a spare part, also update the corresponding regular part
            if (part.isSpare) {
                updateCorrespondingPart(part);
            }
            // If this is a regular part, update its spare (if exists)
            else {
                updateCorrespondingSpare(part);
            }

            updateStats();
            updatePartsHeader();
            updateSparePartsHeader();
            checkAndCelebrate();
            saveState();
        }

        function updateRow(partId) {
            // Find part by ID (not array index) to support both regular parts and minifigs
            var part = partsData.find(function(p) { return p.id === partId; });
            if (!part) return;
            var key = getPartKey(part);

            if (part.type === 'minifig') {
                // Update minifig card
                var card = document.getElementById('minifig-' + partId);
                if (!card) return;

                var isComplete = (userCounts[key] || 0) === 1;
                card.classList.toggle('complete', isComplete);
                card.setAttribute('data-complete', isComplete ? 'true' : 'false');

                return;
            }

            // Handle regular parts
            var countElement = document.getElementById('count-' + partId);
            var row = document.getElementById('row-' + partId);
            if (!row) return;

            var incrementBtn = document.getElementById('inc-' + partId);
            var decrementBtn = document.getElementById('dec-' + partId);

            // Update count display with clickable quantity
            countElement.innerHTML = '<span class="counted">' + userCounts[key] + '</span>/<span class="qty-click" onclick="fillQuantity(' + partId + ')" title="Click to mark all as counted">' + part.quantity + '</span>';

            // Check completion using only the row's own count
            var ownCount = userCounts[key] || 0;
            var isComplete = ownCount >= part.quantity;
            row.setAttribute('data-complete', isComplete ? 'true' : 'false');
            if (incrementBtn) {
                var remaining = part.quantity - ownCount;
                if (isComplete) {
                    incrementBtn.classList.add('complete');
                    incrementBtn.setAttribute('disabled', 'disabled');
                    incrementBtn.textContent = '‚úì';
                } else {
                    incrementBtn.classList.remove('complete');
                    incrementBtn.removeAttribute('disabled');
                    incrementBtn.textContent = remaining <= 1 ? '‚úì' : '+';
                }
            }

            // Show/hide decrement button based on count
            if (decrementBtn) {
                if (userCounts[key] === 0) {
                    decrementBtn.setAttribute('data-hidden-when-zero', '');
                } else {
                    decrementBtn.removeAttribute('data-hidden-when-zero');
                }
            }

            // Update row visibility
            updateTableVisibility();
        }

        function updateStats() {
            var completedPieces = 0;
            var totalPieces = 0;
            var extraSparesCollected = 0;

            // Calculate set completion using regular parts, spare parts, and minifigs
            partsData.forEach(function (part) {
                if (part.isSpare) return;

                totalPieces += part.quantity;

                if (part.type === 'minifig') {
                    // Minifigs don't have spares
                    var key = getPartKey(part);
                    completedPieces += (userCounts[key] || 0);
                } else {
                    // Regular parts can have spares
                    var regularKey = getPartKey(part);
                    var spareKey = regularKey + '_s';

                    var regularCount = userCounts[regularKey] || 0;
                    var spareCount = userCounts[spareKey] || 0;
                    var combinedCount = regularCount + spareCount;

                    // Count up to required quantity for completion
                    completedPieces += Math.min(combinedCount, part.quantity);
                }
            });

            // Check if set is complete (100%)
            var isComplete = completedPieces === totalPieces;

            // Only count extras if set is complete
            if (isComplete) {
                partsData.forEach(function (part) {
                    if (part.isSpare || part.type === 'minifig') return;

                    var regularKey = getPartKey(part);
                    var spareKey = regularKey + '_s';

                    var regularCount = userCounts[regularKey] || 0;
                    var spareCount = userCounts[spareKey] || 0;
                    var combinedCount = regularCount + spareCount;

                    // Count extras beyond required quantity
                    if (combinedCount > part.quantity) {
                        extraSparesCollected += (combinedCount - part.quantity);
                    }
                });
            }

            // Calculate percentage (capped at 100% even with extras)
            var percentage = totalPieces > 0 ? Math.floor((completedPieces / totalPieces) * 100) : 0;

            // Cap both progress bar width and percentage text at 100%
            var progressBarWidth = Math.min(percentage, 100) + '%';
            var percentText = Math.min(percentage, 100) + '%';
            var piecesText = completedPieces + '/' + totalPieces;

            // Add extras to display if any
            if (extraSparesCollected > 0) {
                piecesText += ' +' + extraSparesCollected;
            }

            document.getElementById('completedPieces').textContent = completedPieces;
            document.getElementById('totalPieces').textContent = totalPieces;

            document.getElementById('progressFill').style.width = progressBarWidth;
            document.getElementById('progressBar').setAttribute('data-percentage', percentText);
            document.getElementById('progressBar').setAttribute('data-pieces', piecesText);

            // Update collapsed header progress bar
            document.getElementById('progressFillCollapsed').style.width = progressBarWidth;
            document.getElementById('progressBarCollapsed').setAttribute('data-percentage', percentText);
            document.getElementById('progressBarCollapsed').setAttribute('data-pieces', piecesText);

            // Hide the separate spare parts progress bar since it's now integrated
            hide('spareProgressContainer');
        }

        function saveState() {
            if (!currentSetNumber) return;

            var data = getSetData(currentSetNumber);
            if (data) {
                data.progress = compressProgress(partsData, userCounts);
                data.lastAccessed = Date.now();
                saveSetData(currentSetNumber, data);
            }
        }

        function loadState() {
            if (!currentSetNumber) return;
            var data = getSetData(currentSetNumber);
            if (!data || !data.progress) return;

            var decoded = decompressProgress(data.progress, partsData);
            for (var key in decoded) {
                if (userCounts.hasOwnProperty(key)) {
                    userCounts[key] = decoded[key];
                }
            }
        }

        function resetSet() {
            if (!currentSetNumber || !confirm('Are you sure you want to reset all progress for this set?')) return;

            var data = getSetData(currentSetNumber);
            if (data) {
                data.progress = '';
                saveSetData(currentSetNumber, data);
            }

            // Reset all counts to 0
            partsData.forEach(function (part) {
                var key = getPartKey(part);
                userCounts[key] = 0;
            });

            // Re-render everything
            renderTable();
            renderSparePartsTable();
            updateStats();
            wasComplete = false;
        }
        function showError(message) {
            document.getElementById('error').textContent = message;
            show('error');
        }

        function show() {
            for (var i = 0; i < arguments.length; i++) {
                var el = document.getElementById(arguments[i]);
                if (el) el.classList.remove('hide');
            }
        }

        function hide() {
            for (var i = 0; i < arguments.length; i++) {
                var el = document.getElementById(arguments[i]);
                if (el) el.classList.add('hide');
            }
        }

        document.getElementById('setNumber').addEventListener('keypress', function (e) {
            if (e.key === 'Enter') loadSet();
        });

        function generateBadge() {
            if (!currentSetNumber) {
                alert('Please load a set first');
                return;
            }

            var completedPieces = 0;
            var totalPieces = 0;
            var missingPartsDetailed = [];

            // Calculate set completion using regular parts, spare parts, and minifigs
            partsData.forEach(function (part) {
                if (part.isSpare) return;

                totalPieces += part.quantity;

                var key = getPartKey(part);

                if (part.type === 'minifig') {
                    // Minifigs don't have spares
                    completedPieces += (userCounts[key] || 0);
                    var missing = part.quantity - (userCounts[key] || 0);
                    if (missing > 0) {
                        missingPartsDetailed.push({
                            name: part.name,
                            color: '',
                            quantity: missing,
                            type: 'minifig',
                            imageUrl: part.imageUrl
                        });
                    }
                } else {
                    // Regular parts can have spares
                    var regularKey = key;
                    var spareKey = regularKey + '_s';

                    var regularCount = userCounts[regularKey] || 0;
                    var spareCount = userCounts[spareKey] || 0;
                    var combinedCount = regularCount + spareCount;

                    // Count up to required quantity for completion
                    completedPieces += Math.min(combinedCount, part.quantity);

                    // Calculate missing considering spares
                    var missing = part.quantity - Math.min(combinedCount, part.quantity);
                    if (missing > 0) {
                        missingPartsDetailed.push({
                            name: part.name,
                            color: part.color,
                            quantity: missing,
                            type: 'part',
                            imageUrl: part.imageUrl
                        });
                    }
                }
            });

            var percentage = totalPieces > 0 ? Math.floor((completedPieces / totalPieces) * 100) : 0;

            // Get set info
            var setImageUrl = document.querySelector('#setDetails img') ?
                document.querySelector('#setDetails img').src : null;

            var setName = document.getElementById('setName').textContent;

            var versionParts = currentSetNumber.split('-');
            var versionNumber = versionParts[1];
            var displaySetNumber = versionParts[0];
            var versionLabel = versionNumber !== '1' ? ' v' + versionNumber : '';

            // Generate PNG badge
            generatePNGBadge({
                setName: setName,
                setNumber: displaySetNumber,
                versionLabel: versionLabel,
                percentage: percentage,
                completedPieces: completedPieces,
                totalPieces: totalPieces,
                missingParts: missingPartsDetailed,
                setImageUrl: setImageUrl
            });
        }

        function generatePNGBadge(data) {
            // Pre-load all images before drawing
            var imagesToLoad = [];
            var loadedImages = {};

            // Add set image
            if (data.setImageUrl) {
                imagesToLoad.push({ key: 'setImage', url: getProxiedUrl(data.setImageUrl) });
            }

            // Add part images (max 10)
            var maxParts = Math.min(data.missingParts.length, 10);
            for (var i = 0; i < maxParts; i++) {
                var part = data.missingParts[i];
                if (part.imageUrl) {
                    imagesToLoad.push({ key: 'part_' + i, url: getProxiedUrl(part.imageUrl) });
                }
            }

            // Load all images, then draw
            var loadedCount = 0;
            var totalToLoad = imagesToLoad.length;

            function onImageLoaded() {
                loadedCount++;
                if (loadedCount >= totalToLoad) {
                    drawBadgeWithImages(data, loadedImages);
                }
            }

            if (totalToLoad === 0) {
                drawBadgeWithImages(data, loadedImages);
                return;
            }

            imagesToLoad.forEach(function(item) {
                var img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = function() {
                    loadedImages[item.key] = img;
                    onImageLoaded();
                };
                img.onerror = function() {
                    loadedImages[item.key] = null;
                    onImageLoaded();
                };
                img.src = item.url;
            });
        }

        function drawBadgeWithImages(data, loadedImages) {
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');

            // High-res badge dimensions (2x for retina)
            var scale = 2;
            var setImgSize = 100; // Set image size
            var partImgSize = 40; // Part thumbnail size
            var contentX = setImgSize + 20; // Content starts after image + padding
            var width = 550;

            // Calculate height based on missing parts with images
            var maxParts = Math.min(data.missingParts.length, 10);
            var partRowHeight = 50; // Height per part row (image + text)
            var headerHeight = 120;
            var missingHeaderHeight = data.missingParts.length > 0 ? 45 : 0;
            var partsListHeight = maxParts * partRowHeight;
            var moreTextHeight = data.missingParts.length > 10 ? 30 : 0;
            var footerHeight = 30;

            var height = data.missingParts.length > 0
                ? headerHeight + missingHeaderHeight + partsListHeight + moreTextHeight + footerHeight
                : headerHeight + footerHeight + 50;

            canvas.width = width * scale;
            canvas.height = height * scale;
            ctx.scale(scale, scale);

            // Badge color based on percentage
            var badgeColor = data.percentage === 100 ? '#4CAF50' : (data.percentage >= 80 ? '#FF9800' : '#FF6B6B');

            // Draw rounded rectangle background
            ctx.fillStyle = badgeColor;
            roundRect(ctx, 0, 0, width, height, 16, true);

            // Draw header section
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            roundRectTop(ctx, 0, 0, width, headerHeight, 16);

            // Draw set image placeholder (white rounded square)
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            roundRect(ctx, 10, 10, setImgSize, setImgSize, 8, true);

            // Draw set image if loaded (maintain aspect ratio)
            if (loadedImages.setImage) {
                var img = loadedImages.setImage;
                var imgW = img.naturalWidth || img.width;
                var imgH = img.naturalHeight || img.height;
                var boxSize = setImgSize - 10;
                var scale = Math.min(boxSize / imgW, boxSize / imgH);
                var drawW = imgW * scale;
                var drawH = imgH * scale;
                var drawX = 15 + (boxSize - drawW) / 2;
                var drawY = 15 + (boxSize - drawH) / 2;
                ctx.drawImage(img, drawX, drawY, drawW, drawH);
            } else {
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.font = '12px Arial, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No Image', 10 + setImgSize/2, 10 + setImgSize/2 + 4);
                ctx.textAlign = 'left';
            }

            // Set name (full name, may wrap)
            ctx.fillStyle = 'white';
            ctx.font = 'bold 18px Arial, sans-serif';
            var maxNameWidth = width - contentX - 15;
            var displayName = data.setName;
            // Wrap text if too long
            if (ctx.measureText(displayName).width > maxNameWidth) {
                ctx.font = 'bold 16px Arial, sans-serif';
                if (ctx.measureText(displayName).width > maxNameWidth) {
                    // Two lines
                    var words = displayName.split(' ');
                    var line1 = '';
                    var line2 = '';
                    for (var w = 0; w < words.length; w++) {
                        var testLine = line1 + (line1 ? ' ' : '') + words[w];
                        if (ctx.measureText(testLine).width <= maxNameWidth) {
                            line1 = testLine;
                        } else {
                            line2 = words.slice(w).join(' ');
                            break;
                        }
                    }
                    ctx.fillText(line1, contentX, 28);
                    if (line2) {
                        ctx.font = '14px Arial, sans-serif';
                        ctx.fillText(line2, contentX, 44);
                    }
                } else {
                    ctx.fillText(displayName, contentX, 32);
                }
            } else {
                ctx.fillText(displayName, contentX, 32);
            }

            // Set number (larger)
            ctx.font = 'bold 18px Arial, sans-serif';
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillText('Set ' + data.setNumber + data.versionLabel, contentX, 58);

            // Piece count - at original percentage position
            ctx.font = '16px Arial, sans-serif';
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            var pieceText = data.completedPieces + ' / ' + data.totalPieces + ' pieces';
            var percentBaselineY = 100;
            ctx.fillText(pieceText, contentX, percentBaselineY);

            // Percentage - right aligned
            ctx.font = 'bold 40px Arial, sans-serif';
            ctx.fillStyle = 'white';
            var percentText = data.percentage + '%';
            var percentWidth = ctx.measureText(percentText).width;
            ctx.fillText(percentText, width - 15 - percentWidth, percentBaselineY);

            // Missing parts section
            if (data.missingParts.length > 0) {
                var missingY = headerHeight + 10;

                // Section header
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.fillRect(0, missingY - 5, width, 35);

                ctx.font = 'bold 16px Arial, sans-serif';
                ctx.fillStyle = 'white';
                var missingCount = data.missingParts.reduce(function(sum, p) { return sum + p.quantity; }, 0);
                ctx.fillText('Missing ' + missingCount + ' piece' + (missingCount !== 1 ? 's' : '') + ':', 20, missingY + 17);

                // List missing parts with images
                var listY = missingY + 45;
                var maxItems = Math.min(data.missingParts.length, 10);

                for (var i = 0; i < maxItems; i++) {
                    var part = data.missingParts[i];
                    var rowY = listY + i * partRowHeight;

                    // Draw part image background
                    ctx.fillStyle = 'rgba(255,255,255,0.15)';
                    roundRect(ctx, 15, rowY, partImgSize, partImgSize, 4, true);

                    // Draw part image if loaded
                    var partImg = loadedImages['part_' + i];
                    if (partImg) {
                        ctx.drawImage(partImg, 17, rowY + 2, partImgSize - 4, partImgSize - 4);
                    }

                    // Part text - full name, no truncation
                    var textX = 15 + partImgSize + 10;
                    var textMaxWidth = width - textX - 15;

                    // Quantity badge
                    ctx.font = 'bold 14px Arial, sans-serif';
                    ctx.fillStyle = 'rgba(255,255,255,0.95)';
                    var qtyText = part.quantity + ' √ó';
                    ctx.fillText(qtyText, textX, rowY + 16);

                    // Part name (full)
                    ctx.font = '13px Arial, sans-serif';
                    var nameText = part.name;
                    if (part.type === 'minifig') {
                        nameText += ' (minifig)';
                    }

                    // Wrap name if needed
                    var nameX = textX + ctx.measureText(qtyText).width + 8;
                    var nameMaxWidth = width - nameX - 15;

                    if (ctx.measureText(nameText).width > nameMaxWidth) {
                        // Split into two lines
                        var nameWords = nameText.split(' ');
                        var nameLine1 = '';
                        var nameLine2 = '';
                        for (var nw = 0; nw < nameWords.length; nw++) {
                            var testName = nameLine1 + (nameLine1 ? ' ' : '') + nameWords[nw];
                            if (ctx.measureText(testName).width <= nameMaxWidth) {
                                nameLine1 = testName;
                            } else {
                                nameLine2 = nameWords.slice(nw).join(' ');
                                break;
                            }
                        }
                        ctx.fillText(nameLine1, nameX, rowY + 16);
                        if (nameLine2) {
                            ctx.font = '12px Arial, sans-serif';
                            ctx.fillText(nameLine2, nameX, rowY + 30);
                        }
                    } else {
                        ctx.fillText(nameText, nameX, rowY + 16);
                    }

                    // Color (below name)
                    if (part.color) {
                        ctx.font = '11px Arial, sans-serif';
                        ctx.fillStyle = 'rgba(255,255,255,0.7)';
                        ctx.fillText(part.color, nameX, rowY + 38);
                    }
                }

                if (data.missingParts.length > 10) {
                    var moreY = listY + 10 * partRowHeight + 5;
                    ctx.font = '14px Arial, sans-serif';
                    ctx.fillStyle = 'rgba(255,255,255,0.7)';
                    ctx.fillText('\u2026 and ' + (data.missingParts.length - 10) + ' more missing pieces', 20, moreY);
                }
            }

            // Watermark
            ctx.font = 'bold 16px Arial, sans-serif';
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.textAlign = 'right';
            ctx.fillText('bricktally.app', width - 15, height - 14);
            ctx.textAlign = 'left';

            // Convert to data URL and show modal
            var dataUrl = canvas.toDataURL('image/png');
            showBadgeModal(dataUrl, data);
        }

        function roundRect(ctx, x, y, width, height, radius, fill) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) ctx.fill();
        }

        function roundRectTop(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height);
            ctx.lineTo(x, y + height);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        }

        function showBadgeModal(imageDataUrl, data) {
            var modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 20px;';

            var content = document.createElement('div');
            content.style.cssText = 'background: var(--bg-secondary); padding: 30px; border-radius: 8px; max-width: 550px; width: 100%;';

            // Create filename: bricktally-<set-id>-<set-name>-<missing count or complete>.png
            var safeSetName = data.setName.toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')  // Replace non-alphanumeric with hyphens
                .replace(/^-+|-+$/g, '')       // Remove leading/trailing hyphens
                .substring(0, 30);             // Limit length
            var missingCount = data.totalPieces - data.completedPieces;
            var missingSuffix = missingCount === 0 ? 'complete' : missingCount + '-missing';
            var filename = 'bricktally-' + data.setNumber + '-' + safeSetName + '-' + missingSuffix + '.png';

            content.innerHTML = '<h2 style="margin-bottom: 20px; color: var(--text-primary);">BrickTally Badge</h2>' +
                '<p style="color: var(--text-secondary); margin-bottom: 15px;">Download this badge to share on eBay, Facebook Marketplace, or other platforms as proof of your set\'s completeness.</p>' +
                '<div style="margin: 20px 0; text-align: center;">' +
                '<img src="' + imageDataUrl + '" style="max-width: 100%; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);" alt="BrickTally Badge">' +
                '</div>' +
                '<a id="badgeDownload" href="' + imageDataUrl + '" download="' + filename + '" style="display: block; text-decoration: none;">' +
                '<button style="width: 100%; background: var(--green); font-size: 16px; padding: 12px;">Download Badge (PNG)</button>' +
                '</a>' +
                '<button onclick="this.parentElement.parentElement.remove()" style="margin-top: 15px; width: 100%; background: var(--text-secondary);">Close</button>';

            modal.appendChild(content);
            document.body.appendChild(modal);

            modal.onclick = function (e) {
                if (e.target === modal) modal.remove();
            };
        }

        function exportToBrickLink() {
            if (!currentSetNumber) {
                alert('Please load a set first');
                return;
            }

            var missingParts = [];
            var missingMinifigs = [];

            partsData.forEach(function (part) {
                if (part.isSpare) return;

                var key = getPartKey(part);

                if (part.type === 'minifig') {
                    var missing = part.quantity - (userCounts[key] || 0);
                    if (missing > 0) {
                        missingMinifigs.push({
                            partNum: part.partNum,
                            name: part.name,
                            quantity: missing
                        });
                    }
                } else {
                    // For regular parts, include spare parts in completion calculation
                    var regularCount = userCounts[key] || 0;
                    var spareKey = key + '_s';
                    var spareCount = userCounts[spareKey] || 0;
                    var combinedCount = Math.min(regularCount + spareCount, part.quantity);
                    var missing = part.quantity - combinedCount;

                    if (missing > 0) {
                        missingParts.push({
                            partNum: part.partNum,
                            color: part.color,
                            quantity: missing,
                            name: part.name
                        });
                    }
                }
            });

            if (missingParts.length === 0 && missingMinifigs.length === 0) {
                alert('No missing pieces! Your set is complete.');
                return;
            }

            // Generate BrickLink XML
            var xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += '<INVENTORY>\n';

            // Parts
            missingParts.forEach(function (part) {
                xml += '  <ITEM>\n';
                xml += '    <ITEMTYPE>P</ITEMTYPE>\n';
                xml += '    <ITEMID>' + part.partNum + '</ITEMID>\n';
                xml += '    <COLORNAME>' + part.color + '</COLORNAME>\n';
                xml += '    <MINQTY>' + part.quantity + '</MINQTY>\n';
                xml += '  </ITEM>\n';
            });

            // Minifigs
            missingMinifigs.forEach(function (minifig) {
                xml += '  <ITEM>\n';
                xml += '    <ITEMTYPE>M</ITEMTYPE>\n';
                xml += '    <ITEMID>' + minifig.partNum + '</ITEMID>\n';
                xml += '    <MINQTY>' + minifig.quantity + '</MINQTY>\n';
                xml += '  </ITEM>\n';
            });

            xml += '</INVENTORY>';

            var blob = new Blob([xml], { type: 'text/xml' });
            var url = window.URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = 'bricklink-wanted-list-' + currentSetNumber.replace('-', '_') + '.xml';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);

            alert('BrickLink XML file downloaded!\n\nTo use:\n1. Go to BrickLink.com\n2. Navigate to "Want" > "Upload"\n3. Select "BrickLink XML" format\n4. Upload the downloaded file');
        }

        function exportToPickABrick() {
            if (!currentSetNumber) {
                alert('Please load a set first');
                return;
            }

            var missingParts = [];

            partsData.forEach(function (part) {
                // Skip minifigs and spare parts
                if (part.type === 'minifig' || part.isSpare) return;

                var key = getPartKey(part);

                // Include spare parts in completion calculation
                var regularCount = userCounts[key] || 0;
                var spareKey = key + '_s';
                var spareCount = userCounts[spareKey] || 0;
                var combinedCount = Math.min(regularCount + spareCount, part.quantity);
                var missing = part.quantity - combinedCount;

                if (missing > 0) {
                    missingParts.push({
                        partNum: part.partNum,
                        name: part.name,
                        color: part.color,
                        colorId: part.colorId,
                        quantity: missing
                    });
                }
            });

            if (missingParts.length === 0) {
                alert('No missing pieces! Your set is complete.');
                return;
            }

            // Generate CSV for Pick a Brick
            var csv = '# Note: Minifigures excluded (not available via Pick a Brick)\n';
            csv += 'Element ID,Design ID,Colour,Quantity,Name\n';

            missingParts.forEach(function (part) {
                // Pick a Brick uses Design ID (same as part number) and Element ID (part+color combination)
                // Since we don't have Element IDs from Rebrickable, we'll use the part number
                csv += ',' + part.partNum + ',' + part.color + ',' + part.quantity + ',"' + part.name + '"\n';
            });

            // Create download
            var blob = new Blob([csv], { type: 'text/csv' });
            var url = window.URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = 'pick-a-brick-list-' + currentSetNumber.replace('-', '_') + '.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);

            alert('Pick a Brick CSV file downloaded!\n\nNote: This is a reference list. You\'ll need to manually search and add items on LEGO.com/pick-a-brick as they don\'t support bulk import.');
        }

        function exportMissingPartsText() {
            if (!currentSetNumber) {
                alert('Please load a set first');
                return;
            }

            var missingParts = [];
            var missingMinifigs = [];

            partsData.forEach(function (part) {
                if (part.isSpare) return;

                var key = getPartKey(part);

                if (part.type === 'minifig') {
                    var missing = part.quantity - (userCounts[key] || 0);
                    if (missing > 0) {
                        missingMinifigs.push({
                            partNum: part.partNum,
                            name: part.name,
                            quantity: missing
                        });
                    }
                } else {
                    // Include spare parts in completion calculation
                    var regularCount = userCounts[key] || 0;
                    var spareKey = key + '_s';
                    var spareCount = userCounts[spareKey] || 0;
                    var combinedCount = Math.min(regularCount + spareCount, part.quantity);
                    var missing = part.quantity - combinedCount;

                    if (missing > 0) {
                        missingParts.push({
                            partNum: part.partNum,
                            name: part.name,
                            color: part.color,
                            quantity: missing
                        });
                    }
                }
            });

            if (missingParts.length === 0 && missingMinifigs.length === 0) {
                alert('No missing pieces! Your set is complete.');
                return;
            }

            // Generate readable text list
            var text = 'Missing Pieces for Set ' + currentSetNumber.split('-')[0] + '\n';
            text += '='.repeat(50) + '\n\n';

            if (missingParts.length > 0) {
                text += 'PARTS:\n';
                missingParts.forEach(function (part) {
                    text += part.quantity + 'x ' + part.partNum + ' - ' + part.name + ' (' + part.color + ')\n';
                });
            }

            if (missingMinifigs.length > 0) {
                text += '\nMINIFIGURES:\n';
                missingMinifigs.forEach(function (minifig) {
                    text += minifig.quantity + 'x ' + minifig.partNum + ' - ' + minifig.name + '\n';
                });
            }

            text += '\n' + '='.repeat(50) + '\n';
            text += 'Total unique parts missing: ' + missingParts.length + '\n';
            if (missingMinifigs.length > 0) {
                text += 'Total unique minifigs missing: ' + missingMinifigs.length + '\n';
            }

            var totalPieces = 0;
            missingParts.forEach(function (p) { totalPieces += p.quantity; });
            text += 'Total pieces missing: ' + totalPieces + '\n';

            // Create download
            var blob = new Blob([text], { type: 'text/plain' });
            var url = window.URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = 'missing-parts-' + currentSetNumber.replace('-', '_') + '.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        function exportToRebrickable() {
            if (!currentSetNumber) {
                alert('Please load a set first');
                return;
            }

            // Collect counted parts, merging spare counts into regular parts
            var partCounts = {}; // key: "partNum,colorId" ‚Üí total count

            partsData.forEach(function(part) {
                if (part.isSpare) return; // spares are merged into regular below

                var key = getPartKey(part);
                var count = userCounts[key] || 0;

                // Add spare count for this part+color combination
                var spareKey = key + '_s';
                var spareCount = userCounts[spareKey] || 0;

                var total = count + spareCount;
                if (total <= 0) return;

                var csvKey = part.partNum + ',' + part.colorId;
                partCounts[csvKey] = (partCounts[csvKey] || 0) + total;
            });

            if (Object.keys(partCounts).length === 0) {
                alert('No parts counted yet.');
                return;
            }

            var csv = 'Part,Color,Quantity\n';
            for (var csvKey in partCounts) {
                csv += csvKey + ',' + partCounts[csvKey] + '\n';
            }

            var blob = new Blob([csv], { type: 'text/csv' });
            var url = window.URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = 'rebrickable-partlist-' + currentSetNumber.replace('-', '_') + '.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        var wasComplete = false; // Add with global variables

        function checkAndCelebrate() {
            var completedPieces = 0;
            var totalPieces = 0;

            // Calculate set completion using regular parts, spare parts, and minifigs
            partsData.forEach(function (part) {
                if (part.isSpare) return;

                totalPieces += part.quantity;

                if (part.type === 'minifig') {
                    // Minifigs don't have spares
                    var key = getPartKey(part);
                    completedPieces += (userCounts[key] || 0);
                } else {
                    // Regular parts can have spares
                    var regularKey = getPartKey(part);
                    var spareKey = regularKey + '_s';

                    var regularCount = userCounts[regularKey] || 0;
                    var spareCount = userCounts[spareKey] || 0;
                    var combinedCount = regularCount + spareCount;

                    // Count up to required quantity for completion
                    completedPieces += Math.min(combinedCount, part.quantity);
                }
            });

            var isNowComplete = completedPieces === totalPieces && totalPieces > 0;

            if (isNowComplete && !wasComplete) {
                triggerFireworks();
            }

            wasComplete = isNowComplete;
        }

        function triggerFireworks() {
            var container = document.getElementById('fireworksContainer');
            container.style.display = 'block';
            container.innerHTML = '';

            // Create Lottie animation
            var animation = lottie.loadAnimation({
                container: container,
                renderer: 'svg',
                loop: false,
                autoplay: true,
                path: '/assets/fireworks.json' // Fireworks animation
            });

            // Hide after animation completes
            animation.addEventListener('complete', function () {
                setTimeout(function () {
                    container.style.display = 'none';
                    container.innerHTML = '';
                }, 500);
            });

            // Show congratulations message
            setTimeout(function () {
                var congrats = document.createElement('div');
                congrats.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--bg-secondary); padding: 40px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); z-index: 10001; text-align: center; animation: scaleIn 0.3s ease;';
                congrats.innerHTML = '<h2 style="color: var(--green); font-size: 36px; margin-bottom: 15px;">üéâ Complete!</h2>' +
                    '<p style="color: var(--text-primary); font-size: 18px; margin-bottom: 20px;">All pieces accounted for!</p>' +
                    '<button onclick="this.parentElement.remove()" style="padding: 12px 30px; font-size: 16px;">Awesome!</button>';
                document.body.appendChild(congrats);

                // Add scale-in animation
                var style = document.createElement('style');
                style.textContent = '@keyframes scaleIn { from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } to { transform: translate(-50%, -50%) scale(1); opacity: 1; } }';
                document.head.appendChild(style);
            }, 1000);
        }
    </script>

    <div id="fireworksContainer"></div>

    <footer class="app-footer">
        <span class="footer-tagline">Made with ‚ù§Ô∏è for LEGO¬Æ enthusiasts</span>
        <!-- VERSION_PLACEHOLDER: updated by pre-commit hook -->
        <a href="/changelog" id="versionInfo" class="footer-version-link">v1.24.2 (edeed90)</a>
    </footer>
</body>

</html>